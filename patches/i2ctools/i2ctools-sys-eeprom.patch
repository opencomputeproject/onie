Patch to add the sys_eeprom command to x86_64

Copyright (C) 2014 Puneet <puneet@cumulusnetworks.com>
Copyright (C) 2014 david_yang <david_yang@accton.com>
Copyright (C) 2014 Curt Brune <curt@cumulusnetworks.com>

diff --git a/Makefile b/Makefile
index 0c859b3..144e1bc 100644
--- a/Makefile
+++ b/Makefile
@@ -34,4 +34,9 @@ KERNELVERSION	:= $(shell uname -r)
 all:
 
 SRCDIRS	:= include tools
+
+ifeq ($(SYSEEPROM_ENABLE),yes)
+SRCDIRS	:= $(SRCDIRS) sys_eeprom
+endif
+
 include $(SRCDIRS:%=%/Module.mk)

diff --git a/sys_eeprom/24cXX.c b/sys_eeprom/24cXX.c
index 54c6342..be194ad 100644
--- a/sys_eeprom/24cXX.c
+++ b/sys_eeprom/24cXX.c
@@ -44,7 +44,7 @@ static int i2c_write_2b(struct eeprom *e, __u8 buf[2])
 	r = i2c_smbus_write_byte_data(e->fd, buf[0], buf[1]);
 	if(r < 0)
 		fprintf(stderr, "Error i2c_write_2b: %s\n", strerror(errno));
-	usleep(10);
+	usleep(1000);
 	return r;
 }
 
diff --git a/sys_eeprom/Module.mk b/sys_eeprom/Module.mk
new file mode 100644
index 0000000..5b59b5a
--- /dev/null
+++ b/sys_eeprom/Module.mk
@@ -0,0 +1,32 @@
+#sys_eeprom Makefile
+
+SYS_EEPROM_DIR := sys_eeprom
+SYS_EEPROM_FLAGS :=  -O2 -Iinclude -lz
+SYS_EEPROM_TARGETS:= onie-syseeprom
+
+$(SYS_EEPROM_DIR)/onie-syseeprom: $(SYS_EEPROM_DIR)/sys_eeprom.o \
+	$(SYS_EEPROM_DIR)/onie_tlvinfo.o $(SYS_EEPROM_DIR)/24cXX.o
+	$(CC) $(CFLAGS) $(SYS_EEPROM_FLAGS) $(LDFLAGS) -o $@ $^
+
+$(SYS_EEPROM_DIR)/sys_eeprom.o: $(SYS_EEPROM_DIR)/sys_eeprom.c \
+	$(SYS_EEPROM_DIR)/onie_tlvinfo.c $(SYS_EEPROM_DIR)/onie_tlvinfo.h \
+	$(SYS_EEPROM_DIR)/sys_eeprom_platform.h
+	$(CC) $(CFLAGS) $(LD_FLAGS) $(SYS_EEPROM_FLAGS) -c $< -o $@
+
+$(SYS_EEPROM_DIR)/onie_tlvinfo.o: $(SYS_EEPROM_DIR)/onie_tlvinfo.c \
+	$(SYS_EEPROM_DIR)/onie_tlvinfo.h $(SYS_EEPROM_DIR)/24cXX.c \
+	$(SYS_EEPROM_DIR)/24cXX.h $(SYS_EEPROM_DIR)/sys_eeprom_platform.h
+	$(CC) $(CFLAGS) $(LD_FLAGS) $(SYS_EEPROM_FLAGS) -c $< -o $@
+
+$(SYS_EEPROM_DIR)/24cXX.o: $(SYS_EEPROM_DIR)/24cXX.c \
+	$(INCLUDE_DIR)/linux/i2c-dev.h $(SYS_EEPROM_DIR)/24cXX.h
+	$(CC) $(CFLAGS) $(SYS_EEPROM_FLAGS) -c $< -o $@
+
+all-sys_eeproms: $(addprefix $(SYS_EEPROM_DIR)/,$(SYS_EEPROM_TARGETS))
+
+clean-sys_eeproms:
+	$(RM) $(addprefix $(SYS_EEPROM_DIR)/,*.o $(SYS_EEPROM_TARGETS))
+
+all: all-sys_eeproms
+
+clean: clean-sys_eeproms
diff --git a/sys_eeprom/onie_tlvinfo.c b/sys_eeprom/onie_tlvinfo.c
new file mode 100644
index 0000000..cf88f70
--- /dev/null
+++ b/sys_eeprom/onie_tlvinfo.c
@@ -0,0 +1,798 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "24cXX.h"
+#include "onie_tlvinfo.h"
+
+/* Set to 1 if we've read EEPROM into memory */
+static int has_been_read = 0;
+/* Set to 1 if the EEPROM contents were valid when read from hardware */
+static int hw_eeprom_valid = 1;
+
+static inline int is_multicast_ether_addr(const u_int8_t *addr)
+{
+    return 0x01 & addr[0];
+}
+
+static inline int is_zero_ether_addr(const u_int8_t *addr)
+{
+    return !(addr[0] | addr[1] | addr[2] | addr[3] | addr[4] | addr[5]);
+}
+
+static inline int is_valid_ether_addr(const u_int8_t *addr)
+{
+    return !is_multicast_ether_addr(addr) && !is_zero_ether_addr(addr);
+}
+
+static int set_bytes(char *buf, const char *string, int * converted_accum)
+{
+    char *p = (char *) string;
+    int   i;
+    uint  byte;
+
+    if (!p) {
+	printf("ERROR: NULL string passed in.\n");
+	return -1;
+    }
+    /* Convert string to bytes */
+    for (i = 0, p = (char *)string; (i < TLV_VALUE_MAX_LEN) && (*p != 0);
+	 i++) {
+	while ((*p == ' ') || (*p == '\t') || (*p == ',') ||
+	       (*p == ';')) {
+	    p++;
+	}
+	if (*p != 0) {
+	    if (!isdigit(*p)) {
+		printf("ERROR: Non-digit found in byte string: (%s)\n", string);
+		return -1;
+	    }
+	    byte = strtoul(p, &p, 0);
+	    if (byte >= 256) {
+		printf("ERROR: The value specified is greater than 255: (%u) " \
+		       "in string: %s\n", byte, string);
+		return -1;
+	    }
+	    buf[i] = byte & 0xFF;
+	}
+    }
+    if ((i == TLV_VALUE_MAX_LEN) && (*p != 0)) {
+	printf("ERROR: Trying to assign too many bytes "
+	       "(max: %d) in string: %s\n", TLV_VALUE_MAX_LEN, string);
+	return -1;
+    }
+    *converted_accum = i;
+    return 0;
+}
+
+/*
+ *  set_date
+ *
+ *  Validates the format of the data string
+ *
+ *  This function takes a pointer to a date string (i.e. MM/DD/YYYY hh:mm:ss)
+ *  and validates that the format is correct. If so the string is copied
+ *  to the supplied buffer.
+ */
+static int set_date(char *buf, const char *string)
+{
+    int i;
+
+    if (!string) {
+	printf("ERROR: NULL date string passed in.\n");
+	return -1;
+    }
+    if (strlen(string) != 19) {
+	printf("ERROR: Date strlen() != 19 -- %d\n", strlen(string));
+	printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n", string);
+	return -1;
+    }
+    for (i = 0; string[i] != 0; i++) {
+	switch (i) {
+	case 2:
+	case 5:
+	    if (string[i] != '/') {
+		printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+		       string);
+		return -1;
+	    }
+	    break;
+	case 10:
+	    if (string[i] != ' ') {
+		printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+		       string);
+		return -1;
+	    }
+	    break;
+	case 13:
+	case 16:
+	    if (string[i] != ':') {
+		printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+		       string);
+		return -1;
+	    }
+	    break;
+	default:
+	    if (!isdigit(string[i])) {
+		printf("ERROR: Bad date format (MM/DD/YYYY hh:mm:ss): %s\n",
+		       string);
+		return -1;
+	    }
+	    break;
+	}
+    }
+    strcpy(buf, string);
+    return 0;
+}
+
+/*
+ *  is_valid_tlv
+ *
+ *  Perform basic sanity checks on a TLV field. The TLV is pointed to
+ *  by the parameter provided.
+ *      1. The type code is not reserved (0x00 or 0xFF)
+ */
+static inline bool is_valid_tlv(tlvinfo_tlv_t *tlv)
+{
+    return((tlv->type != 0x00) && (tlv->type != 0xFF));
+}
+
+/*
+ *  is_hex
+ *
+ *  Tests if character is an ASCII hex digit
+ */
+static inline char is_hex(char p)
+{
+    return (((p >= '0') && (p <= '9')) ||
+	    ((p >= 'A') && (p <= 'F')) ||
+	    ((p >= 'a') && (p <= 'f')));
+}
+
+/*
+ *  set_mac
+ *
+ *  Converts a string MAC address into a binary buffer.
+ *
+ *  This function takes a pointer to a MAC address string
+ *  (i.e."XX:XX:XX:XX:XX:XX", where "XX" is a two-digit hex number).
+ *  The string format is verified and then converted to binary and
+ *  stored in a buffer.
+ */
+static int set_mac(char *buf, const char *string)
+{
+    char *p = (char *) string;
+    int   i;
+    int   err = 0;
+    char *end;
+
+    if (!p) {
+	printf("ERROR: NULL mac addr string passed in.\n");
+	return -1;
+    }
+    if (strlen(p) != 17) {
+	printf("ERROR: MAC address strlen() != 17 -- %d\n", strlen(p));
+	printf("ERROR: Bad MAC address format: %s\n", string);
+	return -1;
+    }
+    for (i = 0; i < 17; i++) {
+	if ((i % 3) == 2) {
+	    if (p[i] != ':') {
+		err++;
+		printf("ERROR: mac: p[%i] != :, found: `%c'\n",
+		       i, p[i]);
+		break;
+	    }
+	    continue;
+	} else if (!is_hex(p[i])) {
+	    err++;
+	    printf("ERROR: mac: p[%i] != hex digit, found: `%c'\n",
+		   i, p[i]);
+	    break;
+	}
+    }
+    if (err != 0) {
+	printf("ERROR: Bad MAC address format: %s\n", string);
+	return -1;
+    }
+    /* Convert string to binary */
+    for (i = 0, p = (char *)string; i < 6; i++) {
+	buf[i] = p ? strtoul(p, &end, 16) : 0;
+	if (p) {
+	    p = (*end) ? end + 1 : end;
+	}
+    }
+    if (!is_valid_ether_addr((char *)buf)) {
+	printf("ERROR: MAC address must not be 00:00:00:00:00:00, "
+	       "a multicast address or FF:FF:FF:FF:FF:FF.\n");
+	printf("ERROR: Bad MAC address format: %s\n", string);
+	return -1;
+    }
+    return 0;
+}
+
+/*
+ *  is_valid_tlvinfo_header
+ *
+ *  Perform sanity checks on the first 11 bytes of the TlvInfo EEPROM
+ *  data pointed to by the parameter:
+ *      1. First 8 bytes contain null-terminated ASCII string "TlvInfo"
+ *      2. Version byte is 1
+ *      3. Total length bytes contain value which is less than or equal
+ *         to the allowed maximum (2048-11)
+ *
+ */
+static inline bool is_valid_tlvinfo_header(tlvinfo_header_t *hdr)
+{
+    int max_size = TLV_TOTAL_LEN_MAX;
+    return((strcmp(hdr->signature, TLV_INFO_ID_STRING) == 0) &&
+	   (hdr->version == TLV_INFO_VERSION) &&
+	   (be16_to_cpu(hdr->totallen) <= max_size) );
+}
+
+/*
+ *  decode_tlv_value
+ *
+ *  Decode a single TLV value into a string.
+
+ *  The validity of EEPROM contents and the TLV field have been verified
+ *  prior to calling this function.
+ */
+#define DECODE_NAME_MAX     20
+
+static void decode_tlv_value(tlvinfo_tlv_t * tlv, char* value)
+{
+    int i;
+
+    switch (tlv->type) {
+    case TLV_CODE_PRODUCT_NAME:
+    case TLV_CODE_PART_NUMBER:
+    case TLV_CODE_SERIAL_NUMBER:
+    case TLV_CODE_MANUF_DATE:
+    case TLV_CODE_LABEL_REVISION:
+    case TLV_CODE_PLATFORM_NAME:
+    case TLV_CODE_ONIE_VERSION:
+    case TLV_CODE_MANUF_NAME:
+    case TLV_CODE_MANUF_COUNTRY:
+    case TLV_CODE_VENDOR_NAME:
+    case TLV_CODE_DIAG_VERSION:
+    case TLV_CODE_SERVICE_TAG:
+	memcpy(value, tlv->value, tlv->length);
+	value[tlv->length] = 0;
+	break;
+    case TLV_CODE_MAC_BASE:
+	sprintf(value, "%02X:%02X:%02X:%02X:%02X:%02X",
+		tlv->value[0], tlv->value[1], tlv->value[2],
+		tlv->value[3], tlv->value[4], tlv->value[5]);
+	break;
+    case TLV_CODE_DEVICE_VERSION:
+	sprintf(value, "%u", tlv->value[0]);
+	break;
+    case TLV_CODE_MAC_SIZE:
+	sprintf(value, "%u", (tlv->value[0] << 8) | tlv->value[1]);
+	break;
+    case TLV_CODE_VENDOR_EXT:
+	value[0] = 0;
+	for (i = 0; (i < (TLV_DECODE_VALUE_MAX_LEN/5)) && (i < tlv->length);
+	     i++) {
+	    sprintf(value, "%s 0x%02X", value, tlv->value[i]);
+	}
+	break;
+    case TLV_CODE_CRC_32:
+	sprintf(value, "0x%02X%02X%02X%02X",
+		tlv->value[0], tlv->value[1], tlv->value[2],
+		tlv->value[3]);
+	break;
+    default:
+	value[0] = 0;
+	for (i = 0; (i < (TLV_DECODE_VALUE_MAX_LEN/5)) && (i < tlv->length);
+	     i++) {
+	    sprintf(value, "%s 0x%02X", value, tlv->value[i]);
+	}
+	break;
+    }
+
+}
+
+/*
+ *  decode_tlv
+ *
+ *  Print a string representing the contents of the TLV field. The format of
+ *  the string is:
+ *      1. The name of the field left justified in 20 characters
+ *      2. The type code in hex right justified in 5 characters
+ *      3. The length in decimal right justified in 4 characters
+ *      4. The value, left justified in however many characters it takes
+ *  The validity of EEPROM contents and the TLV field have been verified
+ *  prior to calling this function.
+ */
+#define DECODE_NAME_MAX     20
+
+static void decode_tlv(tlvinfo_tlv_t * tlv)
+{
+    char name[DECODE_NAME_MAX];
+    char value[TLV_DECODE_VALUE_MAX_LEN];
+    int i;
+
+    decode_tlv_value(tlv, value);
+
+    strncpy(name, tlv_type2name(tlv->type), DECODE_NAME_MAX);
+    name[DECODE_NAME_MAX-1] = 0;
+
+    printf("%-20s 0x%02X %3d %s\n", name, tlv->type, tlv->length, value);
+}
+
+/*
+ *  is_checksum_valid
+ *
+ *  Validate the checksum in the provided TlvInfo EEPROM data. First,
+ *  verify that the TlvInfo header is valid, then make sure the last
+ *  TLV is a CRC-32 TLV. Then calculate the CRC over the EEPROM data
+ *  and compare it to the value stored in the EEPROM CRC-32 TLV.
+ */
+static bool is_checksum_valid(u_int8_t *eeprom)
+{
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t    * eeprom_crc;
+    unsigned int       calc_crc;
+    unsigned int       stored_crc;
+
+    // Is the eeprom header valid?
+    if (!is_valid_tlvinfo_header(eeprom_hdr)) {
+	return(FALSE);
+    }
+
+    // Is the last TLV a CRC?
+    eeprom_crc = (tlvinfo_tlv_t *) &eeprom[sizeof(tlvinfo_header_t) +
+					   be16_to_cpu(eeprom_hdr->totallen) -
+					   (sizeof(tlvinfo_tlv_t) + 4)];
+    if ((eeprom_crc->type != TLV_CODE_CRC_32) || (eeprom_crc->length != 4)) {
+	return(FALSE);
+    }
+
+    // Calculate the checksum
+    calc_crc = crc32(0, (void *)eeprom, sizeof(tlvinfo_header_t) +
+		     be16_to_cpu(eeprom_hdr->totallen) - 4);
+    stored_crc = ((eeprom_crc->value[0] << 24) | (eeprom_crc->value[1] << 16) |
+		  (eeprom_crc->value[2] <<  8) | eeprom_crc->value[3]);
+    return(calc_crc == stored_crc);
+}
+
+/*
+ *  update_crc
+ *
+ *  This function updates the CRC-32 TLV. If there is no CRC-32 TLV, then
+ *  one is added. This function should be called after each update to the
+ *  EEPROM structure, to make sure the CRC is always correct.
+ */
+static void update_crc(u_int8_t *eeprom)
+{
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t    * eeprom_crc;
+    unsigned int       calc_crc;
+
+    // Is the eeprom header valid?
+    if (!is_valid_tlvinfo_header(eeprom_hdr)) {
+	return;
+    }
+    // Is the last TLV a CRC?
+    eeprom_crc = (tlvinfo_tlv_t *) &eeprom[sizeof(tlvinfo_header_t) +
+					   be16_to_cpu(eeprom_hdr->totallen) -
+					   (sizeof(tlvinfo_tlv_t) + 4)];
+    if (eeprom_crc->type != TLV_CODE_CRC_32) {
+	if ((be16_to_cpu(eeprom_hdr->totallen) + sizeof(tlvinfo_tlv_t) + 4) >
+	    TLV_TOTAL_LEN_MAX) {
+	    return;
+	}
+	eeprom_crc = (tlvinfo_tlv_t *) &eeprom[sizeof(tlvinfo_header_t) +
+					       be16_to_cpu(
+						   eeprom_hdr->totallen)];
+	eeprom_hdr->totallen = cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) +
+					   sizeof(tlvinfo_tlv_t) + 4);
+	eeprom_crc->type = TLV_CODE_CRC_32;
+    }
+    eeprom_crc->length = 4;
+
+    // Calculate the checksum
+    calc_crc = crc32(0, (void *)eeprom,
+		     sizeof(tlvinfo_header_t) +
+		     be16_to_cpu(eeprom_hdr->totallen) - 4);
+    eeprom_crc->value[0] = (calc_crc >> 24) & 0xFF;
+    eeprom_crc->value[1] = (calc_crc >> 16) & 0xFF;
+    eeprom_crc->value[2] = (calc_crc >>  8) & 0xFF;
+    eeprom_crc->value[3] = (calc_crc >>  0) & 0xFF;
+    return;
+}
+
+/*
+ *  show_eeprom
+ *
+ *  Display the contents of the EEPROM
+ */
+void show_eeprom(u_int8_t *eeprom)
+{
+    int tlv_end;
+    int curr_tlv;
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t    * eeprom_tlv;
+
+    if ( !is_valid_tlvinfo_header(eeprom_hdr) ) {
+	printf("EEPROM does not contain data in a valid TlvInfo format.\n");
+	return;
+    }
+
+    printf("TlvInfo Header:\n");
+    printf("   Id String:    %s\n", eeprom_hdr->signature);
+    printf("   Version:      %d\n", eeprom_hdr->version);
+    printf("   Total Length: %d\n", be16_to_cpu(eeprom_hdr->totallen));
+    printf("TLV Name             Code Len Value\n");
+    printf("-------------------- ---- --- -----\n");
+    curr_tlv = sizeof(tlvinfo_header_t);
+    tlv_end  = sizeof(tlvinfo_header_t) + be16_to_cpu(eeprom_hdr->totallen);
+    while (curr_tlv < tlv_end) {
+	eeprom_tlv = (tlvinfo_tlv_t *) &eeprom[curr_tlv];
+	if (!is_valid_tlv(eeprom_tlv)) {
+	    printf("Invalid TLV field starting at EEPROM offset %d\n",
+		   curr_tlv);
+	    return;
+	}
+	decode_tlv(eeprom_tlv);
+	curr_tlv += sizeof(tlvinfo_tlv_t) + eeprom_tlv->length;
+    }
+    printf("Checksum is %s.\n", is_checksum_valid(eeprom) ? "valid" :
+	   "invalid");
+
+#ifdef DEBUG
+    printf("EEPROM dump: (0x%x bytes)", SYS_EEPROM_SIZE);
+    for (i = 0; i < SYS_EEPROM_SIZE; i++) {
+	if ((i % 16) == 0)
+	    printf("\n%02X: ", i);
+	printf("%02X ", eeprom[i]);
+    }
+    printf("\n");
+#endif
+    return;
+}
+
+/*
+ *  read_eeprom
+ *
+ *  Read the EEPROM into memory, if it hasn't already been read.
+ */
+int read_eeprom(u_int8_t *eeprom)
+{
+    int ret;
+    tlvinfo_header_t *eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t *eeprom_tlv = (tlvinfo_tlv_t *)&eeprom[
+	sizeof(tlvinfo_header_t)];
+
+    if (has_been_read)
+	return 0;
+
+    /* Read the header */
+    ret = read_sys_eeprom((void *)eeprom_hdr, 0, sizeof(tlvinfo_header_t));
+    /* If the header was successfully read, read the TLVs */
+    if ((ret == 0) && is_valid_tlvinfo_header(eeprom_hdr)) {
+	ret = read_sys_eeprom((void *)eeprom_tlv, sizeof(tlvinfo_header_t),
+			      be16_to_cpu(eeprom_hdr->totallen));
+    }
+    // If the contents are invalid, start over with default contents
+    if (!is_valid_tlvinfo_header(eeprom_hdr))
+	fprintf(stderr,
+                "Notice:  Invalid TLV header found.  Using default contents.\n");
+    if (!is_checksum_valid(eeprom))
+	fprintf(stderr,
+                "Notice:  Invalid TLV checksum found.  Using default contents.\n");
+    if ( !is_valid_tlvinfo_header(eeprom_hdr) || !is_checksum_valid(eeprom) ){
+	strcpy(eeprom_hdr->signature, TLV_INFO_ID_STRING);
+	eeprom_hdr->version = TLV_INFO_VERSION;
+	eeprom_hdr->totallen = cpu_to_be16(0);
+	update_crc(eeprom);
+	/* Note that the contents of the hardware is not valid */
+	hw_eeprom_valid = 0;
+    }
+    has_been_read = 1;
+
+#ifdef DEBUG
+    show_eeprom(eeprom);
+#endif
+    return ret;
+}
+
+/*
+ *  prog_eeprom
+ *  Write the EEPROM data from CPU memory to the hardware.
+ */
+int prog_eeprom(u_int8_t * eeprom)
+{
+    int ret = 0;
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    int eeprom_len;
+
+    eeprom_len = sizeof(tlvinfo_header_t) + be16_to_cpu(eeprom_hdr->totallen);
+    ret = write_sys_eeprom(eeprom, eeprom_len);
+    if (ret) {
+	printf("Programming failed.\n");
+	return -1;
+    }
+
+    /* After writing the HW contents are valid */
+    hw_eeprom_valid = 1;
+
+    printf("Programming passed.\n");
+    return 0;
+}
+
+/*
+ * is_sys_eeprom_valid - Is the EEPROM binary data in hardware valid
+ */
+static int is_sys_eeprom_valid()
+{
+    return hw_eeprom_valid;
+}
+
+/*
+ *  tlvinfo_find_tlv
+ *
+ *  This function finds the TLV with the supplied code in the EERPOM.
+ *  An offset from the beginning of the EEPROM is returned in the
+ *  eeprom_index parameter if the TLV is found.
+ */
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode,
+			     int *eeprom_index)
+{
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t    * eeprom_tlv;
+    int eeprom_end;
+
+    // Make sure the EEPROM contents are valid
+    if (!is_valid_tlvinfo_header(eeprom_hdr) || !is_checksum_valid(eeprom)) {
+	return(FALSE);
+    }
+    // Search through the TLVs, looking for the first one which matches the
+    // supplied type code.
+    *eeprom_index = sizeof(tlvinfo_header_t);
+    eeprom_end = sizeof(tlvinfo_header_t) + be16_to_cpu(eeprom_hdr->totallen);
+    while (*eeprom_index < eeprom_end) {
+	eeprom_tlv = (tlvinfo_tlv_t *) &eeprom[*eeprom_index];
+	if (!is_valid_tlv(eeprom_tlv)) {
+	    return(FALSE);
+	}
+	if (eeprom_tlv->type == tcode) {
+	    return(TRUE);
+	}
+	*eeprom_index += sizeof(tlvinfo_tlv_t) + eeprom_tlv->length;
+    }
+    return(FALSE);
+}
+
+/*
+ *  tlvinfo_decode_tlv
+ *
+ *  This function finds the TLV with the supplied code in the EERPOM
+ *  and decodes the value into the buffer provided.
+ */
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value)
+{
+    int eeprom_index;
+    tlvinfo_tlv_t * eeprom_tlv;
+
+    // Find the TLV and then decode it
+    if (tlvinfo_find_tlv(eeprom, tcode, &eeprom_index)) {
+        eeprom_tlv = (tlvinfo_tlv_t *) &eeprom[eeprom_index];
+        decode_tlv_value(eeprom_tlv, value);
+        return TRUE;
+    }
+
+    return FALSE;
+}
+
+/*
+ *  tlvinfo_delete_tlv
+ *
+ *  This function deletes the TLV with the specified type code from the
+ *  EEPROM.
+ */
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code)
+{
+    int eeprom_index;
+    int tlength;
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t * eeprom_tlv;
+
+    // Find the TLV and then move all following TLVs "forward"
+    if (tlvinfo_find_tlv(eeprom, code, &eeprom_index)) {
+	eeprom_tlv = (tlvinfo_tlv_t *) &eeprom[eeprom_index];
+	tlength = sizeof(tlvinfo_tlv_t) + eeprom_tlv->length;
+	memcpy(&eeprom[eeprom_index], &eeprom[eeprom_index+tlength],
+	       sizeof(tlvinfo_header_t) + be16_to_cpu(eeprom_hdr->totallen) -
+	       eeprom_index - tlength);
+	eeprom_hdr->totallen = cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) -
+					   tlength);
+	update_crc(eeprom);
+	return(TRUE);
+    }
+    return(FALSE);
+}
+
+/*
+ *  tlvinfo_add_tlv
+ *
+ *  This function adds a TLV to the EEPROM, converting the value (a string) to
+ *  the format in which it will be stored in the EEPROM.
+ */
+#define MAX_TLV_VALUE_LEN   256
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval)
+{
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+    tlvinfo_tlv_t * eeprom_tlv;
+    int new_tlv_len = 0;
+    u_int32_t value;
+    char data[MAX_TLV_VALUE_LEN];
+    int eeprom_index;
+    int max_size = TLV_TOTAL_LEN_MAX;
+
+    // Encode each TLV type into the format to be stored in the EERPOM
+    switch (tcode) {
+    case TLV_CODE_PRODUCT_NAME:
+    case TLV_CODE_PART_NUMBER:
+    case TLV_CODE_SERIAL_NUMBER:
+    case TLV_CODE_LABEL_REVISION:
+    case TLV_CODE_PLATFORM_NAME:
+    case TLV_CODE_ONIE_VERSION:
+    case TLV_CODE_MANUF_NAME:
+    case TLV_CODE_MANUF_COUNTRY:
+    case TLV_CODE_VENDOR_NAME:
+    case TLV_CODE_DIAG_VERSION:
+    case TLV_CODE_SERVICE_TAG:
+	strncpy(data, strval, MAX_TLV_VALUE_LEN);
+	new_tlv_len = min(MAX_TLV_VALUE_LEN, strlen(strval));
+	break;
+    case TLV_CODE_DEVICE_VERSION:
+	value = strtoul(strval, NULL, 0);
+	if (value >= 256) {
+	    printf("ERROR: Device version must be 255 or less. Value " \
+		   "supplied: %u", value);
+	    return(FALSE);
+	}
+	data[0] = value & 0xFF;
+	new_tlv_len = 1;
+	break;
+    case TLV_CODE_MAC_SIZE:
+	value = strtoul(strval, NULL, 0);
+	if (value >= 65536) {
+	    printf("ERROR: MAC Size must be 65535 or less. Value " \
+		   "supplied: %u", value);
+	    return(FALSE);
+	}
+	data[0] = (value >> 8) & 0xFF;
+	data[1] = value & 0xFF;
+	new_tlv_len = 2;
+	break;
+    case TLV_CODE_MANUF_DATE:
+	if (set_date(data, strval) != 0) {
+	    return(FALSE);
+	}
+	new_tlv_len = 19;
+	break;
+    case TLV_CODE_MAC_BASE:
+	if (set_mac(data, strval) != 0) {
+	    return(FALSE);
+	}
+	new_tlv_len = 6;
+	break;
+    case TLV_CODE_CRC_32:
+	printf("WARNING: The CRC TLV is set automatically and cannot be set " \
+	       "manually.\n");
+	return(FALSE);
+    case TLV_CODE_VENDOR_EXT:
+    default:
+	if (set_bytes(data, strval, &new_tlv_len) != 0 ) {
+	    return(FALSE);
+	}
+	break;
+    }
+
+    // Is there room for this TLV?
+    if ((be16_to_cpu(eeprom_hdr->totallen) + sizeof(tlvinfo_tlv_t) +
+	 new_tlv_len) > max_size) {
+	printf("ERROR: There is not enough room in the EERPOM to save data.\n");
+	return(FALSE);
+    }
+
+    // Add TLV at the end, overwriting CRC TLV if it exists
+    if (tlvinfo_find_tlv(eeprom, TLV_CODE_CRC_32, &eeprom_index)) {
+	eeprom_hdr->totallen = cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen)
+					   - sizeof(tlvinfo_tlv_t) - 4);
+    } else {
+	eeprom_index = sizeof(tlvinfo_header_t) +
+	    be16_to_cpu(eeprom_hdr->totallen);
+    }
+    eeprom_tlv = (tlvinfo_tlv_t *) &eeprom[eeprom_index];
+    eeprom_tlv->type = tcode;
+    eeprom_tlv->length = new_tlv_len;
+    memcpy(eeprom_tlv->value, data, new_tlv_len);
+
+    // Update the total length and calculate (add) a new CRC-32 TLV
+    eeprom_hdr->totallen = cpu_to_be16(be16_to_cpu(eeprom_hdr->totallen) +
+				       sizeof(tlvinfo_tlv_t) + new_tlv_len);
+    update_crc(eeprom);
+
+    return(TRUE);
+}
+
+/*
+ * read_sys_eeprom - read the hwinfo from i2c EEPROM
+ */
+int read_sys_eeprom(void *eeprom_data, int offset, int len)
+{
+    int ret = 0;
+    struct eeprom e;
+    int i = 0;
+    u_int8_t *c;
+    int addr = SYS_EEPROM_OFFSET + offset;
+
+    c = eeprom_data;
+    if (eeprom_open(SYS_EEPROM_I2C_DEVICE, SYS_EEPROM_I2C_ADDR,
+		    EEPROM_TYPE_8BIT_ADDR, &e)) {
+	printf("ERROR: Cannot open I2C device\n");
+	return -1;
+    }
+    for (i = 0; i < len; i++) {
+	*c = eeprom_read_byte(&e, addr);
+	c++; addr++;
+    }
+    eeprom_close(&e);
+    return ret;
+}
+
+/*
+ * write_sys_eeprom - write the hwinfo to i2c EEPROM
+ */
+int write_sys_eeprom(void *eeprom_data, int len)
+{
+    int ret = 0;
+    struct eeprom e;
+    int i = 0;
+    u_int8_t *c;
+    u_int16_t  addr = SYS_EEPROM_OFFSET;
+
+    c = eeprom_data;
+    for (i = 0; i < len; i++) {
+	if (eeprom_open(SYS_EEPROM_I2C_DEVICE, SYS_EEPROM_I2C_ADDR,
+			EEPROM_TYPE_8BIT_ADDR, &e)) {
+	    printf("ERROR: Cannot open I2C device\n");
+	    return -1;
+	}
+	eeprom_write_byte(&e, addr, *c);
+	eeprom_close(&e);
+	c++; addr++;
+    }
+
+    return ret;
+}
+
+void update_eeprom_header(u_int8_t *eeprom)
+{
+    tlvinfo_header_t * eeprom_hdr = (tlvinfo_header_t *) eeprom;
+
+    strcpy(eeprom_hdr->signature, TLV_INFO_ID_STRING);
+    eeprom_hdr->version = TLV_INFO_VERSION;
+    eeprom_hdr->totallen = cpu_to_be16(0);
+    update_crc(eeprom);
+}
+
+/*
+ *  show_tlv_code_list - Display the list of TLV codes and names
+ */
+void show_tlv_code_list(void)
+{
+    int i;
+
+    printf("TLV Code    TLV Name\n");
+    printf("========    =================\n");
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	printf("0x%02x        %s\n",
+	       tlv_code_list[i].m_code,
+	       tlv_code_list[i].m_name);
+    }
+}
diff --git a/sys_eeprom/onie_tlvinfo.h b/sys_eeprom/onie_tlvinfo.h
new file mode 100644
index 0000000..5714f37
--- /dev/null
+++ b/sys_eeprom/onie_tlvinfo.h
@@ -0,0 +1,172 @@
+/*
+ *  The Definition of the TlvInfo EEPROM format can be found at onie.org or
+ *  github.com/onie
+ */
+
+#include <asm/byteorder.h>
+
+#define be16_to_cpu(x)  __be16_to_cpu(x)
+#define cpu_to_be16(x)   __cpu_to_be16(x)
+
+#define FALSE   0
+#define TRUE    (!FALSE)
+typedef unsigned char bool;
+
+#define min(x, y)          ((x) > (y) ? (y) : (x))
+
+/*
+ * Tlvinf header: Layout of the header for the TlvInfo format
+ *
+ * See the end of this file for details of this eeprom format
+ */
+struct __attribute__ ((__packed__)) tlvinfo_header_s {
+    char    signature[8];   /* 0x00 - 0x07 EEPROM Tag "TlvInfo" */
+    u_int8_t      version;  /* 0x08        Structure version */
+    u_int16_t     totallen; /* 0x09 - 0x0A Length of all data which follows */
+};
+typedef struct tlvinfo_header_s tlvinfo_header_t;
+
+// Header Field Constants
+#define TLV_INFO_ID_STRING      "TlvInfo"
+#define TLV_INFO_VERSION        0x01
+#define TLV_TOTAL_LEN_MAX       (SYS_EEPROM_SIZE - sizeof(tlvinfo_header_t))
+
+/*
+ * TlvInfo TLV: Layout of a TLV field
+ */
+struct __attribute__ ((__packed__)) tlvinfo_tlv_s {
+    u_int8_t  type;
+    u_int8_t  length;
+    u_int8_t  value[0];
+};
+typedef struct tlvinfo_tlv_s tlvinfo_tlv_t;
+
+/* Maximum length of a TLV value in bytes */
+#define TLV_VALUE_MAX_LEN        255
+
+/**
+ *  The TLV Types.
+ *
+ *  Keep these in sync with tlv_code_list in cmd_sys_eeprom.c
+ */
+#define TLV_CODE_PRODUCT_NAME   0x21
+#define TLV_CODE_PART_NUMBER    0x22
+#define TLV_CODE_SERIAL_NUMBER  0x23
+#define TLV_CODE_MAC_BASE       0x24
+#define TLV_CODE_MANUF_DATE     0x25
+#define TLV_CODE_DEVICE_VERSION 0x26
+#define TLV_CODE_LABEL_REVISION 0x27
+#define TLV_CODE_PLATFORM_NAME  0x28
+#define TLV_CODE_ONIE_VERSION   0x29
+#define TLV_CODE_MAC_SIZE       0x2A
+#define TLV_CODE_MANUF_NAME     0x2B
+#define TLV_CODE_MANUF_COUNTRY  0x2C
+#define TLV_CODE_VENDOR_NAME    0x2D
+#define TLV_CODE_DIAG_VERSION   0x2E
+#define TLV_CODE_SERVICE_TAG    0x2F
+#define TLV_CODE_VENDOR_EXT     0xFD
+#define TLV_CODE_CRC_32         0xFE
+
+/*
+ *  Struct for displaying the TLV codes and names.
+ */
+struct tlv_code_desc {
+    u_int8_t m_code;
+    char* m_name;
+};
+
+/*
+ *  List of TLV codes and names.
+ */
+static const struct tlv_code_desc tlv_code_list[] = {
+    { TLV_CODE_PRODUCT_NAME	 , "Product Name"},
+    { TLV_CODE_PART_NUMBER	 , "Part Number"},
+    { TLV_CODE_SERIAL_NUMBER     , "Serial Number"},
+    { TLV_CODE_MAC_BASE	         , "Base MAC Address"},
+    { TLV_CODE_MANUF_DATE	 , "Manufacture Date"},
+    { TLV_CODE_DEVICE_VERSION    , "Device Version"},
+    { TLV_CODE_LABEL_REVISION    , "Label Revision"},
+    { TLV_CODE_PLATFORM_NAME     , "Platform Name"},
+    { TLV_CODE_ONIE_VERSION	 , "Loader Version"},
+    { TLV_CODE_MAC_SIZE	         , "MAC Addresses"},
+    { TLV_CODE_MANUF_NAME	 , "Manufacturer"},
+    { TLV_CODE_MANUF_COUNTRY     , "Country Code"},
+    { TLV_CODE_VENDOR_NAME	 , "Vendor Name"},
+    { TLV_CODE_DIAG_VERSION	 , "Diag Version"},
+    { TLV_CODE_SERVICE_TAG       , "Service Tag"},
+    { TLV_CODE_VENDOR_EXT	 , "Vendor Extension"},
+    { TLV_CODE_CRC_32	         , "CRC-32"},
+};
+
+static inline const char* tlv_type2name(u_int8_t type)
+{
+    char* name = "Unknown";
+    int   i;
+
+    for (i = 0; i < sizeof(tlv_code_list)/sizeof(tlv_code_list[0]); i++) {
+	if (tlv_code_list[i].m_code == type) {
+	    name = tlv_code_list[i].m_name;
+	    break;
+	}
+    }
+    return name;
+}
+
+/*
+ * The max decode value is currently for the 'raw' type or the 'vendor
+ * extension' type, both of which have the same decode format.  The
+ * max decode string size is computed as follows:
+ *
+ *   strlen(" 0xFF") * TLV_VALUE_MAX_LEN + 1
+ *
+ */
+#define TLV_DECODE_VALUE_MAX_LEN    ((5 * TLV_VALUE_MAX_LEN) + 1)
+
+
+/*
+ * Each platform must define the following platform-specific macros
+ * in sys_eeprom_platform.h:
+ * SYS_EEPROM_SIZE: size of usable eeprom
+ * SYS_EEPROM_I2C_DEVICE: i2c-bus
+ * SYS_EEPROM_I2C_ADDR: address on the bus
+ * The following may also be defined in sys_eeprom_platform.h, else
+ * the defaults with take over:
+ * SYS_EEPROM_MAX_SIZE: Total size of the eeprom
+ * SYS_EEPROM_OFFSET: offset from where the ONIE header starts
+ */
+#include "sys_eeprom_platform.h"
+
+#ifndef SYS_EEPROM_MAX_SIZE
+#define SYS_EEPROM_MAX_SIZE     2048
+#endif
+
+#ifndef SYS_EEPROM_OFFSET
+#define SYS_EEPROM_OFFSET       0
+#endif
+
+#ifndef SYS_EEPROM_SIZE
+  #error SYS_EEPROM_SIZE not defined!
+#endif
+
+#ifndef SYS_EEPROM_I2C_DEVICE
+  #error SYS_EEPROM_I2C_DEVICE not defined!
+#endif
+
+#ifndef SYS_EEPROM_I2C_ADDR
+  #error SYS_EEPROM_I2C_ADDR not defined!
+#endif
+
+#if (SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET > SYS_EEPROM_MAX_SIZE)
+  #error SYS_EEPROM_SIZE + SYS_EEPROM_OFFSET is greater than SYS_EEPROM_MAX_SIZE
+#endif
+
+// Access functions to onie_tlvinfo
+void show_eeprom(u_int8_t *eeprom);
+int read_eeprom(u_int8_t *eeprom);
+int prog_eeprom(u_int8_t * eeprom);
+void update_eeprom_header(u_int8_t *eeprom);
+bool tlvinfo_find_tlv(u_int8_t *eeprom, u_int8_t tcode, int *eeprom_index);
+bool tlvinfo_delete_tlv(u_int8_t * eeprom, u_int8_t code);
+bool tlvinfo_add_tlv(u_int8_t * eeprom, int tcode, char * strval);
+bool tlvinfo_decode_tlv(u_int8_t *eeprom, u_int8_t tcode, char* value);
+void show_tlv_code_list(void);
diff --git a/sys_eeprom/sys_eeprom.c b/sys_eeprom/sys_eeprom.c
new file mode 100644
index 0000000..a77837f
--- /dev/null
+++ b/sys_eeprom/sys_eeprom.c
@@ -0,0 +1,169 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include "onie_tlvinfo.h"
+
+static u_int8_t eeprom[SYS_EEPROM_SIZE];
+/*
+ *  This macro defines the sys_eeprom command line command.
+ */
+cmd_usage()
+{
+    static const char *usage =
+	"Display and program the system EEPROM data block.\n"
+	"Usage: sys-eeprom [-h][-l] [-e] [-s <code>=<value>,...]\n"
+	"   With no arguments display the EEPROM contents.\n"
+	"   -h --help\n"
+	"      Display usage\n"
+	"   -l --list\n"
+	"      List the understood TLV codes and names.\n"
+	"   -e --erase\n"
+	"      Reset the EEPROM data.\n"
+	"   -g --get <code>\n"
+	"      Look up a TLV by code and write the value to stdout.\n"
+	"   -s --set <code>=<value>,<code>=<value>...\n"
+	"      Set a TLV code to a value.\n"
+	"      If no value, TLV is deleted.\n";
+
+    fprintf(stderr, "%s", usage);
+    exit(1);
+}
+/*
+ *  do_sys_eeprom
+ *  This function implements the sys_eeprom command.
+ */
+int main(int argc, char * const argv[])
+{
+    int count = 0;
+    int err = 0;
+    int update = 0;
+    char *value, *subopts, *tname;
+    int index, c, i, option_index, tcode;
+    char tlv_value[TLV_DECODE_VALUE_MAX_LEN];
+
+    const size_t tlv_code_count = sizeof(tlv_code_list) /
+	sizeof(tlv_code_list[0]);
+
+    char *tokens[tlv_code_count + 1];
+    const char *short_options = "hels:g:";
+    const struct option long_options[] = {
+	{"help",    no_argument,          0,    'h'},
+	{"list",    no_argument,          0,    'l'},
+	{"erase",   no_argument,          0,    'e'},
+	{"set",     required_argument,    0,    's'},
+	{"get",     required_argument,    0,    'g'},
+	{0,         0,                    0,      0},
+    };
+
+    for (i = 0; i < tlv_code_count; i++) {
+	    tokens[i] = (char *) malloc(6);
+	    sprintf(tokens[i], "0x%x", tlv_code_list[i].m_code);
+    }
+    tokens[tlv_code_count] = NULL;
+
+    while (TRUE) {
+	c = getopt_long(argc, argv, short_options,
+			long_options, &option_index);
+	if (c == EOF)
+	    break;
+
+	count++;
+	switch (c) {
+	case 'h':
+	    cmd_usage();
+	    break;
+
+	case 'l':
+	    show_tlv_code_list();
+	    break;
+
+	case 'e':
+	    if (read_eeprom(eeprom)) {
+                err = 1;
+		goto syseeprom_err;
+	    }
+	    update_eeprom_header(eeprom);
+	    update = 1;
+	    break;
+
+	case 's':
+	    subopts = optarg;
+	    while (*subopts != '\0' && !err) {
+		if ((index = getsubopt(&subopts, tokens, &value)) != -1) {
+		    if (read_eeprom(eeprom)) {
+                        err = 1;
+			goto syseeprom_err;
+		    }
+		    tcode = strtoul(tokens[index], NULL, 0);
+		    for (i = 0; i < tlv_code_count; i++) {
+			if (tlv_code_list[i].m_code == tcode) {
+			    tname = tlv_code_list[i].m_name;
+			}
+		    }
+		    if (tlvinfo_delete_tlv(eeprom, tcode) == TRUE) {
+			    printf("Deleting TLV 0x%x: %s\n", tcode, tname);
+		    }
+		    if (value) {
+			if (!tlvinfo_add_tlv(eeprom, tcode, value)) {
+                            err = 1;
+			    goto syseeprom_err;
+			} else {
+			    printf("Adding   TLV 0x%x: %s\n", tcode, tname);
+			}
+		    }
+		    update = 1;
+		} else {
+		    err = 1;
+		    printf("ERROR: Invalid option: %s\n", value);
+		    goto syseeprom_err;
+		}
+	    }
+	break;
+
+	case 'g':
+            if (read_eeprom(eeprom)) {
+                err = 1;
+                goto syseeprom_err;
+            }
+            tcode = strtoul(optarg, NULL, 0);
+            if (tlvinfo_decode_tlv(eeprom, tcode, tlv_value)) {
+                printf("%s\n", tlv_value);
+            } else {
+                err = 1;
+                printf("ERROR: TLV code not present in EEPROM: 0x%02x\n", tcode);
+            }
+            goto syseeprom_err;
+	break;
+
+	default:
+	    cmd_usage();
+            err = 1;
+	    break;
+	}
+    }
+    if (!count) {
+	if (argc > 1) {
+	    cmd_usage();
+            err = 1;
+	} else {
+	    if (read_eeprom(eeprom)) {
+                err = 1;
+                goto syseeprom_err;
+            }
+	    show_eeprom(eeprom);
+	}
+    }
+    if (update) {
+	if (prog_eeprom(eeprom)) {
+            err = 1;
+            goto syseeprom_err;
+        }
+	show_eeprom(eeprom);
+    }
+syseeprom_err:
+    for (i = 0; i < tlv_code_count; i++) {
+	free(tokens[i]);
+    }
+    return  (err == 0) ? 0 : 1;
+}
diff --git a/sys_eeprom/sys_eeprom_platform.h b/sys_eeprom/sys_eeprom_platform.h
new file mode 100644
index 0000000..529f774
--- /dev/null
+++ b/sys_eeprom/sys_eeprom_platform.h
@@ -0,0 +1,4 @@
+#ifndef __SYS_EEPROM_PLATFORM_H_
+#define __SYS_EEPROM_PLATFORM_H_
+
+#endif /* __SYS_EEPROM_PLATFORM_H_ */
