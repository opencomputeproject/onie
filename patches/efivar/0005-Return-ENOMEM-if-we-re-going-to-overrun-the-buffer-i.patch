From 86e17a239a3d16aa1520b6c06146857f48def8f0 Mon Sep 17 00:00:00 2001
Subject: [PATCH 05/13] Return ENOMEM if we're going to overrun the buffer in
 read_file.

I don't actually think this case will ever happen in efivar, since the
paths we're reading from are generated internally and always point at
sysfs or proc and /cannot/ be that large, but it's still the right thing
to do.

Based on the bug and patch reported in this thread:
https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=764386

Signed-off-by: Peter Jones <pjones@redhat.com>
Signed-off-by: Curt Brune <curt@cumulusnetworks.com>

diff --git a/src/util.h b/src/util.h
index fdeb649..a12cdd7 100644
--- a/src/util.h
+++ b/src/util.h
@@ -57,6 +57,15 @@ read_file(int fd, uint8_t **buf, size_t *bufsize)
 		if (s == 0) {
 			break;
 		} else if (s == 4096) {
+			/* See if we're going to overrun and return an error
+			 * instead. */
+			if (size > (size_t)-1 - 4096) {
+				free(*buf);
+				*buf = NULL;
+				*bufsize = 0;
+				errno = ENOMEM;
+				return -1;
+			}
 			newbuf = realloc(*buf, size + 4096);
 			if (newbuf == NULL) {
 				int saved_errno = errno;
