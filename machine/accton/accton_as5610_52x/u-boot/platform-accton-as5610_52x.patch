Platform support for the Accton as5610_52x

diff --git a/README b/README
index e016b91..f2cdb66 100644
--- a/README
+++ b/README
@@ -545,19 +545,6 @@ The following options need to be configured:
 		crash. This is needed for buggy hardware (uc101) where
 		no pull down resistor is connected to the signal IDE5V_DD7.
 
-                CONFIG_FDT_ENV_SIZE
-
-                When fixing up the device tree before booting store
-                the value of the CONFIG_ENV_SIZE macro in the device
-                tree.  This allows the OS to know how the environment
-                area is defined.
-
-                The method first finds the FDT node with a property
-                called "label" whose value is "uboot-env".
-
-                If the node is found then set the "env_size" property to
-                CONFIG_ENV_SIZE.
-
 		CONFIG_MACH_TYPE	[relevant for ARM only][mandatory]
 
 		This setting is mandatory for all boards that have only one
diff --git a/arch/powerpc/cpu/mpc85xx/ddr-gen3.c b/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
index ef0dd1d..fb4c262 100644
--- a/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
+++ b/arch/powerpc/cpu/mpc85xx/ddr-gen3.c
@@ -309,15 +309,18 @@ void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
 #ifdef CONFIG_SYS_FSL_ERRATUM_DDR111_DDR134
 	timeout_save = timeout;
 #endif
+
 	total_gb_size_per_controller >>= 4;	/* shift down to gb size */
 	debug("total %d GB\n", total_gb_size_per_controller);
 	debug("Need to wait up to %d * 10ms\n", timeout);
 
+	timeout *= 2;/*Kenny Cheng Timeout X2*/
 	/* Poll DDR_SDRAM_CFG_2[D_INIT] bit until auto-data init is done.  */
 	while ((in_be32(&ddr->sdram_cfg_2) & SDRAM_CFG2_D_INIT) &&
 		(timeout >= 0)) {
 		udelay(10000);		/* throttle polling rate */
 		timeout--;
+		debug("Wait %d %x\n",timeout,in_be32(&ddr->sdram_cfg_2));
 	}
 
 	if (timeout <= 0)
diff --git a/arch/powerpc/lib/board.c b/arch/powerpc/lib/board.c
index 5595329..384a0ef 100644
--- a/arch/powerpc/lib/board.c
+++ b/arch/powerpc/lib/board.c
@@ -856,10 +856,6 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	mac_read_from_eeprom();
 #endif
 
-#ifdef CONFIG_POPULATE_SERIAL_NUMBER
-	populate_serial_number();
-#endif
-
 #ifdef	CONFIG_HERMES
 	if ((gd->board_type >> 16) == 2)
 		bd->bi_ethspeed = gd->board_type & 0xFFFF;
@@ -1008,11 +1004,6 @@ void board_init_r(gd_t *id, ulong dest_addr)
 	last_stage_init();
 #endif
 
-#ifdef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
-	WATCHDOG_RESET();
-	env_write_default_if_crc_bad();
-#endif
-
 #if defined(CONFIG_CMD_BEDBUG)
 	WATCHDOG_RESET();
 	bedbug_init();
diff --git a/arch/powerpc/lib/bootm.c b/arch/powerpc/lib/bootm.c
index 78ac9e7..3371103 100644
--- a/arch/powerpc/lib/bootm.c
+++ b/arch/powerpc/lib/bootm.c
@@ -293,7 +293,7 @@ static int boot_body_linux(bootm_headers_t *images)
 		ft_board_setup(*of_flat_tree, gd->bd);
 #endif
 
-#if defined(CONFIG_FDT_ENV_SIZE) && defined(CONFIG_ENV_SIZE)
+#ifdef CONFIG_FDT_ENV_SIZE
 		do_fixup_by_prop_u32(*of_flat_tree, "label", "uboot-env", 10,
 				     "env_size", CONFIG_ENV_SIZE, 1);
 #endif
diff --git a/board/accton/as5610_52x/Makefile b/board/accton/as5610_52x/Makefile
new file mode 100644
index 0000000..1e87705
--- /dev/null
+++ b/board/accton/as5610_52x/Makefile
@@ -0,0 +1,57 @@
+#
+# Copyright 2004 Freescale Semiconductor.
+# (C) Copyright 2001-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).o
+
+COBJS-y	+= $(BOARD).o $(BOARD)_misc.o
+COBJS-y	+= law.o
+COBJS-y	+= tlb.o
+COBJS-y	+= usb.o
+COBJS-y	+= ddr.o eq.o
+COBJS-y	+= cmd_dram_test.o
+COBJS-$(CONFIG_FASTPATH) += bootf.o
+
+SRCS	:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS-y))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(call cmd_link_o_target, $(OBJS))
+
+clean:
+	rm -f $(OBJS) $(SOBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/accton/as5610_52x/as5610_52x.c b/board/accton/as5610_52x/as5610_52x.c
new file mode 100644
index 0000000..4bb49d3
--- /dev/null
+++ b/board/accton/as5610_52x/as5610_52x.c
@@ -0,0 +1,558 @@
+/*
+ * Copyright 2004, 2007, 200 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2002 Scott McNutt <smcnutt@artesyncp.com>
+ *
+ * Curt Brune <curt@cumulusnetworks.com>
+ * Vidya Ravipati <vidya@cumulusnetworks.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+#include <config.h>
+#include <pci.h>
+#include <asm/processor.h>
+#include <asm/mmu.h>
+#include <asm/cache.h>
+#include <asm/immap_85xx.h>
+#include <asm/fsl_pci.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_serdes.h>
+#include <miiphy.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#include <fsl_mdio.h>
+#include <tsec.h>
+#include <asm/fsl_law.h>
+#include <asm/mp.h>
+#include <netdev.h>
+
+#include <spd_sdram.h>
+#include <i2c.h>
+#include <sys_eeprom.h>
+#include "board.h"
+#include <version.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static int boot_ok_flag=1;	/*1 OK, 0 fail*/
+int get_boot_ok()
+{
+	return boot_ok_flag;
+}
+
+void set_boot_flag_ok(void)
+{
+	boot_ok_flag = 1;
+}
+
+void set_boot_flag_fail(void)
+{
+	boot_ok_flag = 0;
+}
+
+/*******************************************************************************
+ *
+ * Early initialization
+ *
+ */
+int board_early_init_f(void)
+{
+	return 0;
+}
+
+/*******************************************************************************
+ *
+ * Initialize board and the local bus
+ */
+void local_bus_init(void)
+{
+	volatile ccsr_gur_t *gur = (void *)(CONFIG_SYS_MPC85xx_GUTS_ADDR);
+	volatile fsl_lbc_t *lbc = LBC_BASE_ADDR;
+
+	uint clkdiv;
+	sys_info_t sysinfo;
+
+	get_sys_info(&sysinfo);
+	clkdiv = (lbc->lcrr & LCRR_CLKDIV) * 2;
+
+	gur->lbiuiplldcr1 = 0x00078080;
+	if (clkdiv == 16) {
+		gur->lbiuiplldcr0 = 0x7c0f1bf0;
+	} else if (clkdiv == 8) {
+		gur->lbiuiplldcr0 = 0x6c0f1bf0;
+	} else if (clkdiv == 4) {
+		gur->lbiuiplldcr0 = 0x5c0f1bf0;
+	}
+
+	lbc->lcrr |= 0x00030000;
+
+	asm("sync;isync;msync");
+
+	lbc->ltesr = 0xffffffff;	/* Clear LBC error interrupts */
+	lbc->lteir = 0xffffffff;	/* Enable LBC error interrupts */
+}
+
+int checkboard(void)
+{
+
+	u8    prod, prod_id, prod_rev;
+	u8    cpld_ver, val;
+	char *name;
+
+	prod     = cpld_rd(CPLD_REG_MODEL_TYPE);
+	prod_id  = (prod & CPLD_PCB_MODEL_TYPE_MASK) >>
+		CPLD_PCB_MODEL_TYPE_SHIFT;
+	prod_rev = (prod & CPLD_PCB_VER_MASK) >> CPLD_PCB_VER_SHIFT;
+
+	cpld_ver = cpld_rd(CPLD_REG_VERSION);
+
+	name = (prod_id == 0) ? "AS5610_52X" : "Unknown";
+	printf("Board: Accton %s (hw_id: %d, hw_rev: %d, cpld_ver: 0x%02X)\n",
+		name, prod_id, prod_rev, cpld_ver);
+
+	/*Disable Watch Dog*/
+	val = cpld_rd(CPLD_REG_WATCH_DOG_CTRL);
+	val &= ~CPLD_WATCH_DOG_ENABLE;
+	cpld_wr(CPLD_REG_WATCH_DOG_CTRL, val);
+	udelay(10000);
+
+	local_bus_init();
+
+	return 0;
+}
+
+
+int board_early_init_r(void)
+{
+	const unsigned int flashbase = CONFIG_SYS_FLASH_BASE;
+	const u8 flash_esel = find_tlb_idx((void *)flashbase, 1);
+
+	/*
+	 * Remap Boot flash region to caching-inhibited
+	 * so that flash can be erased properly.
+	 */
+
+	/* Flush d-cache and invalidate i-cache of any FLASH data */
+	flush_dcache();
+	invalidate_icache();
+
+	/* invalidate existing TLB entry for flash */
+	disable_tlb(flash_esel);
+
+	set_tlb(1, flashbase, CONFIG_SYS_FLASH_BASE_PHYS,
+			MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+			0, flash_esel, CONFIG_SYS_FLASH_TLB_SIZE, 1);
+
+       /*Pull reset all in CPLD*/
+        unsigned int reset_duration_val = CONFIG_RESET_DURATION;/*Default Reset Duration*/
+
+        unsigned char *reset_duration = getenv("reset_duration");
+        if(reset_duration)
+        {
+                reset_duration_val = simple_strtoul(reset_duration,NULL,10);
+        }
+
+        reset_duration_val *= 1000;
+
+        unsigned char * reset_env = getenv("reset_all");
+        if(reset_env)
+        {
+                if(strcmp(reset_env,"yes")==0)
+                {
+                        printf("Enable Reset All : Duration %dms\n",reset_duration_val);
+                        *((volatile unsigned char*)0xEA000010)=0xFE;
+                        udelay(reset_duration_val);
+                        *((volatile unsigned char*)0xEA000010)=0xFF;
+                        //udelay(high_delay_val);//Use 'pcidelay' instead
+                }
+        }
+
+	return 0;
+}
+
+
+/*
+ *
+ * setup PCI
+ *
+ * Cribbed from board/freescale/mpc8536ds/mpc8536ds.c
+ *
+ */
+
+#ifdef CONFIG_PCI
+void pci_init_board(void)
+{
+	fsl_pcie_init_board(0);
+}
+#endif
+
+/*******************************************************************************
+ *
+ * PCI device tree massaging
+ */
+#if defined(CONFIG_OF_BOARD_SETUP)
+void ft_board_setup(void *blob, bd_t *bd)
+{
+
+	ft_cpu_setup(blob, bd);
+
+#ifdef CONFIG_HAS_FSL_DR_USB
+	fdt_fixup_dr_usb(blob, bd);
+#endif
+
+	FT_FSL_PCI_SETUP;
+}
+#endif
+
+#ifdef CONFIG_TSEC_ENET
+int board_eth_init(bd_t *bis)
+{
+	struct fsl_pq_mdio_info mdio_info;
+	struct tsec_info_struct tsec_info[4];
+	int num = 0;
+
+#ifdef CONFIG_TSEC1
+	SET_STD_TSEC_INFO(tsec_info[num], 1);
+	num++;
+#endif
+#ifdef CONFIG_TSEC2
+	SET_STD_TSEC_INFO(tsec_info[num], 2);
+	if (is_serdes_configured(SGMII_TSEC2)) {
+		puts("eTSEC2 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+#ifdef CONFIG_TSEC3
+	SET_STD_TSEC_INFO(tsec_info[num], 3);
+	if (is_serdes_configured(SGMII_TSEC3)) {
+		puts("eTSEC3 is in sgmii mode.\n");
+		tsec_info[num].flags |= TSEC_SGMII;
+	}
+	num++;
+#endif
+
+	if (!num) {
+		printf("No TSECs initialized\n");
+		return 0;
+	}
+
+	mdio_info.regs = (struct tsec_mii_mng *)CONFIG_SYS_MDIO_BASE_ADDR;
+	mdio_info.name = DEFAULT_MII_NAME;
+
+	fsl_pq_mdio_init(bis, &mdio_info);
+
+	tsec_eth_init(bis, tsec_info, num);
+
+	return pci_eth_init(bis);
+}
+#endif
+
+void board_reset(void)
+{
+	printf("Using HRESET_REQ to reset board\n");
+
+	/* Set HRESET_REQ */
+	*((volatile int *)0xFF7E00b0) = 0x2;
+
+	while (1);
+
+}
+
+#define HW_MON_I2C_BUS	    (0)
+#define HW_MON_I2C_MUX_ADDR (0x70)
+#define HW_MON_I2C_MUX_BUS  (7)
+#define HW_MON_I2C_ADDR	    (0x29)
+
+static void hwmon_init(void)
+{
+	u8 val;
+	u8 addr = HW_MON_I2C_ADDR;
+
+	enum {
+		W83782G_BANK_SELECT_REG       = 0x4e,
+		W83782G_PWMOUT1_REG           = 0x5b,
+		W83782G_PWMOUT12_CLK_SEL_REG  = 0x5c,
+		W83782G_VBAT_MONITOR_CTRL_REG = 0x5d,
+	};
+
+	i2c_set_bus_num(HW_MON_I2C_BUS);
+
+	/* mux bus-select */
+	val = 0x1 << HW_MON_I2C_MUX_BUS;
+	i2c_write(HW_MON_I2C_MUX_ADDR, 0, 1, &val, 1);
+
+	/*
+	* Configure HW monitor chip per hw spec section 4.11.1.1 page 82.
+	*
+	* For proper fan speed control, set the following register in
+	* W83782G.  This will set the W83782G?™s PWM output frequency
+	* at 93.74Khz.
+	* Reg 0x5C[6:0] <= b000_0000 (binary)
+	* Reg 0x5C[7:0] (bank 4) <= b0000_0000
+	*/
+
+	val = 0x84;
+	i2c_write(addr, W83782G_BANK_SELECT_REG, 1, &val, 1);
+	val = 0x00;
+	i2c_write(addr, W83782G_PWMOUT12_CLK_SEL_REG, 1, &val, 1);
+	val = 0x80;
+	i2c_write(addr, W83782G_BANK_SELECT_REG, 1, &val, 1);
+	val = 0x00;
+	i2c_write(addr, W83782G_PWMOUT12_CLK_SEL_REG, 1, &val, 1);
+	val = 0x01;
+	i2c_write(addr, W83782G_VBAT_MONITOR_CTRL_REG, 1, &val, 1);
+
+	/* Set the fan speed to 50% duty cycle */
+	val = 0x80;
+	i2c_write(addr, W83782G_PWMOUT1_REG, 1, &val, 1);
+
+}
+
+static void fan_pwm_init(void)
+{
+	/*set fan PWM according to config_fan_speed value*/
+	char *config_fan_speed = getenv("config_fan_speed");
+	int val = DEFAULT_FAN_DUTY_CYCLE;
+	if(config_fan_speed != NULL)
+	{
+		val = simple_strtoul(config_fan_speed,NULL,10);
+	}
+
+	val = (val * 0xFF) / 100;	/*DUTY_CYCLE to PWM*/
+	cpld_wr(CPLD_REG_FAN_CONTROL, val);
+}
+
+/*******************************************************************************
+ *
+ * MISC initializations after relocating to RAM.  Full C environment available.
+ * Before configuring network interfaces.
+ *
+ */
+
+int misc_init_r(void)
+{
+	u8 val;
+
+	/*
+	 * Take a few things out of reset:
+	 *   Trident+
+	 *   10G PHYs
+	 *   MGMT 1G PHY
+	 *   USB PHY
+	 *   USB HUB
+	 *   I2C Expander
+	 *   I2C Switch
+	 */
+#if 0
+	/* Step 1 - put SOC and 10G PHYs in reset */
+	val = cpld_rd(CPLD_REG_RESET_CTRL_1);
+	val |= CPLD_RESET_SYSTEM_L;
+	val &= ~CPLD_RESET_BCM56846_L;
+	val &= ~CPLD_RESET_BCM8475_GRP1_L;
+	val &= ~CPLD_RESET_BCM8475_GRP2_L;
+	cpld_wr(CPLD_REG_RESET_CTRL_1, val);
+	udelay(10000);
+
+	/* Step 2 - take 10G PHYs out of reset */
+	val |= CPLD_RESET_BCM8475_GRP1_L;
+	val |= CPLD_RESET_BCM8475_GRP2_L;
+	cpld_wr(CPLD_REG_RESET_CTRL_1, val);
+	udelay(10000);
+
+	/* Step 3 - take SOC out of reset */
+	val |= CPLD_RESET_BCM56846_L;
+	cpld_wr(CPLD_REG_RESET_CTRL_1, val);
+
+
+/*Kenny Cheng*/
+	/* Step 4 - put 1G mgmt phy, usb and i2c devices into reset */
+	val = cpld_rd(CPLD_REG_RESET_CTRL_2);
+	val &= ~CPLD_RESET_BCM5482S_L;
+	val &= ~CPLD_RESET_I2C_SWITCH_L;
+	val &= ~CPLD_RESET_I2C_GPIO_L;
+	val &= ~CPLD_RESET_USB_PHY_L;
+	val &= ~CPLD_RESET_USB_HUB_L;
+	cpld_wr(CPLD_REG_RESET_CTRL_2, val);
+	udelay(10000);
+
+	/* Step 5 - take 1G mgmt phy, usb and i2c devices out of reset */
+	val |= CPLD_RESET_BCM5482S_L;
+	val |= CPLD_RESET_I2C_SWITCH_L;
+	val |= CPLD_RESET_I2C_GPIO_L;
+	val |= CPLD_RESET_USB_PHY_L;
+	val |= CPLD_RESET_USB_HUB_L;
+	cpld_wr(CPLD_REG_RESET_CTRL_2, val);
+	udelay(10000);
+#endif
+
+	//hwmon_init();
+
+	return 0;
+}
+
+
+/* ------------------------------------------------------------------------
+ * FUNCTION: check_fix_env
+ * PURPOSE:  check env, fix it if it is not correct.
+ * INPUT:      None
+ *
+ * OUTPUT:     None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ *          1   = Abort
+ * NOTES:
+ */
+
+#define CHECK_ENV(ENV_NAME,ENV_STRING) \
+    while(1)   \
+    {  \
+       env_string = getenv(ENV_NAME);  \
+       if(env_string != NULL)  \
+       {       \
+               if(strcmp(env_string,ENV_STRING) == 0)  \
+                       break;  \
+       }       \
+       need_update = 1;        \
+       setenv(ENV_NAME,ENV_STRING);    \
+       printf("- Updating $" ENV_NAME " -\n"); \
+    }
+
+int check_fix_env(void)
+{
+    int need_update = 0;
+    char *env_string = NULL;
+
+    CHECK_ENV("ver",U_BOOT_VERSION_STRING)
+    CHECK_ENV("platform",PLATFORM_STRING)
+
+    if(need_update == 1)
+       saveenv();
+
+    return 0;
+}
+
+/*******************************************************************************
+ *
+ * MISC initializations after relocating to RAM.  Full C environment available.
+ *
+ * Go through the CPLD register spec and set interesting bits here.
+ */
+
+extern int usb_hub_init(void);
+extern int populate_env(char *env_name,  u8 type_code);
+extern void env_write_default_if_crc_bad(void);
+
+int last_stage_init(void)
+{
+	u8 val;
+	u8 led;
+
+    /* TI DS100KR800 Equalizer */
+#ifdef CONFIG_EQ_DS100KR800
+    board_init_eq();
+#endif
+
+	/*
+	 * Set u-boot env which is required by ONIE:
+	 */
+
+#if defined(CONFIG_SYS_EEPROM_LOAD_ENV_MAC)
+	mac_read_from_eeprom();
+#endif
+
+#ifdef CONFIG_POPULATE_SERIAL_NUMBER
+    /* serial# */
+    /*populate_serial_number();*/
+    populate_env("serial#", TLV_CODE_SERIAL_NUMBER);
+
+    /* onie_platform */
+    populate_env("onie_platform", TLV_CODE_PLATFORM_NAME);
+
+    /* onie_version */
+    populate_env("onie_version", TLV_CODE_ONIE_VERSION);
+
+#endif
+
+#ifdef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
+    /* Check u-boot environment variable.
+     * If the env in flash is corrupt then
+     * write the default env with a valid CRC.
+     */
+	env_write_default_if_crc_bad();
+#endif
+
+	check_fix_env();
+
+	/*
+	 * Set front panel LEDs to reasonable values:
+	 *
+	 *   Diag	Yellow
+	 *   Fan	Check status, green if good.
+	 *   Locator	Off
+	 */
+
+	val = cpld_rd(CPLD_REG_SYSTEM_STATUS);
+	led = cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_1);
+
+	/* Set diag to blinking yellow. */
+	led &= ~CPLD_SYS_LED_DIAG_MASK;
+	led |= CPLD_SYS_LED_DIAG_AMBER;
+
+	/* Set fan depending on status. */
+	led &= ~CPLD_SYS_LED_FAN_MASK;
+	if (val & (CPLD_SYS_FAN_ABSENT | CPLD_SYS_FAN_BAD)) {
+		printf("WARNING:  System fan is absent or bad.\n");
+		led |= CPLD_SYS_LED_FAN_AMBER;
+	} else {
+		led |= CPLD_SYS_LED_FAN_GREEN;
+	}
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_1, led);
+
+	/* Disable locator LED. */
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_2, CPLD_SYS_LED_LOCATOR_OFF);
+
+	/* aaron_lien, boot up sequence is completed and disable auto flash swizzle.*/
+	val = cpld_rd(CPLD_REG_FLASH_SWIZZLE);
+	cpld_wr(CPLD_REG_FLASH_SWIZZLE, val & 0xFD);
+
+	if(usb_hub_init() != 0)
+		set_boot_flag_fail();
+
+	fan_pwm_init();
+	/*If everything is ok, Diag LED Green ON*/
+	led = cpld_rd(CPLD_REG_SYSTEM_LED_CTRL_1);
+	led &= ~CPLD_SYS_LED_DIAG_MASK;
+	if(get_boot_ok())
+		led |= CPLD_SYS_LED_DIAG_GREEN;
+	else
+		led |= CPLD_SYS_LED_DIAG_AMBER;
+
+	cpld_wr(CPLD_REG_SYSTEM_LED_CTRL_1, led);
+	return 0;
+}
+
+void fdt_fixup_board(void *fdt)
+{
+}
diff --git a/board/accton/as5610_52x/as5610_52x_misc.c b/board/accton/as5610_52x/as5610_52x_misc.c
new file mode 100644
index 0000000..8b80a3b
--- /dev/null
+++ b/board/accton/as5610_52x/as5610_52x_misc.c
@@ -0,0 +1,152 @@
+/*
+* File:        $(BOARD)_cmd.c
+* Purpose:     To define the specific command and
+*              function of this board.
+*
+* Notes:
+* History:
+*  2013/08/26    -- Aaron Lien, Initial version
+*
+* Copyright (C) 2013  Accton Corporation
+*/
+#include <stdarg.h>
+#include <common.h>
+#include <command.h>
+#include <linux/ctype.h>
+#include <linux/stddef.h>
+#include "board.h"
+#include <version.h>
+
+
+#if 0   //local debug print
+#undef debug
+#define debug(fmt,args...)	printf (fmt ,##args)
+#endif	/* local debug print*/
+
+/*******************************************************************************
+ *
+ * CPU Core
+ *
+ */
+
+/* clock ratio table, (e500 core/CCB) x 10 */
+int TBL_core_ccb_ratio[8]={ 40, 45, 10, 15, 20, 25, 30, 35 };
+
+#define SYSCLK_66	     66666667
+#define SYSCLK_83	     83333333
+#define SYSCLK_100      100000000
+#define DDRCLK_166  	166666666 /* DDRCLK on P1_P2 RDB */
+#define DDRCLK_200  	200000000 /* DDRCLK on P1_P2 RDB */
+#define DDRCLK_333  	333333333 /* DDRCLK on P1_P2 RDB */
+#define DDRCLK_400  	400000000 /* DDRCLK on P1_P2 RDB */
+
+/* BT2 R01E CPU=1.2GHz, CCB=600MHz, SYSCLK=100MHz, DDR Data rate=800 MHz;
+ * BT2 R01C CPU=1.0GHz, CCB=500MHz, SYSCLK=100MHz, DDR Data rate=600 MHz;
+ * BT2 R01B CPU=1.0GHz, CCB=333MHz, SYSCLK=66.67MHz, DDR Data rate=667 MHz
+ */
+unsigned long get_board_sys_clk(void)
+{
+    int core_ratio, ccb_ratio, core_speed, r, f;
+
+    /* Core clock : CCB clock */
+    core_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 16) & 0x3F;
+    core_ratio &= 0x07;
+    r = TBL_core_ccb_ratio[core_ratio];
+
+    /* CCB clock : SYSCLK */
+    ccb_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 1) & 0x1F;
+    r *= ccb_ratio;
+
+    /* Core Speed, MHz */
+    core_speed = (*(uint *)CCSR_GBLUTI_PORDEVSR2 >> 19) & 0x1;
+
+    f = core_speed ? 1200 : 1000;
+    f = (f*10)/r;
+
+    if(f < 70)
+        return SYSCLK_66;
+    else if(f < 90)
+	return SYSCLK_83;
+    else
+        return SYSCLK_100;
+
+}
+
+/* use core clock to find DDR data rate !
+ * BT2 R01E CPU=1.2GHz, DDR Data rate=800 MHz; the others DDR Data rate=667MHz
+   Doesn't need anymore
+ */
+unsigned long get_board_data_rate(void)
+{
+    int ddr_ratio=0;
+    unsigned long ddr_clk=0;
+
+    /* DDR Ratio */
+    ddr_ratio = (*(volatile uint *)CCSR_GBLUTI_PORPLLSR >> 8) & 0x1F;
+
+    ddr_clk = (get_board_sys_clk() * ddr_ratio) / 2 ;
+
+    return ddr_clk;
+}
+/*******************************************************************************
+ *
+ * CPLD I/O
+ *
+ */
+u8 cpld_rd(u32 reg)
+{
+	return in_8(((u8 *)CONFIG_SYS_CPLD_BASE + reg));
+}
+
+void cpld_wr(u32 reg, u8 data)
+{
+	out_8(((u8 *)CONFIG_SYS_CPLD_BASE + reg), data);
+}
+
+/*******************************************************************************
+ * u-boot command to show system clock infornation.
+ */
+static int do_show_clock_info(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    int core_ratio, ccb_ratio, ddr_ratio, core_speed, r, f;
+	sys_info_t sysinfo;
+	char buf[32];
+
+    printf("PORPLLSR = 0x%08X\n", *(uint *)CCSR_GBLUTI_PORPLLSR);
+    printf("PORDEVSR2 = 0x%08X\n", *(uint *)CCSR_GBLUTI_PORDEVSR2);
+
+    /* Core clock : CCB clock */
+    core_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 16) & 0x3F;
+    printf("Clock ratio of CPU core and CCB = 0x%08X\n", core_ratio);
+    core_ratio &= 0x07;
+    r = TBL_core_ccb_ratio[core_ratio];
+
+    /* CCB clock : SYSCLK */
+    ccb_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 1) & 0x1F;
+    printf("Clock ratio of CCB and SYSCLK = 0x%08X\n", ccb_ratio);
+    r *= ccb_ratio;
+
+    /* Core Speed, MHz */
+    core_speed = (*(uint *)CCSR_GBLUTI_PORDEVSR2 >> 19) & 0x1;
+    printf("CPU core speed = %sHz\n", core_speed ? "1.2G" : "1G");
+
+    f = core_speed ? 1200 : 1000;
+    printf("System Clock(SYSCLK) = %d MHz\n", (f*10)/r);
+
+    /* DDR clock : DDRCLK */
+    ddr_ratio = (*(uint *)CCSR_GBLUTI_PORPLLSR >> 9) & 0x1F;
+    printf("Clock ratio of DDR complex and DDRCLK = 0x%08X\n", ddr_ratio);
+
+    /* DDR data rate */
+	get_sys_info(&sysinfo);
+	printf("Configuration of DDR data rate = %s MT/s\n",
+				strmhz(buf, sysinfo.freqDDRBus));
+
+    return 0;
+}
+
+U_BOOT_CMD(
+    clkinfo, CONFIG_SYS_MAXARGS, 1,	do_show_clock_info,
+    "clkinfo\t- show clock information.",
+    ""
+);
diff --git a/board/accton/as5610_52x/board.h b/board/accton/as5610_52x/board.h
new file mode 100644
index 0000000..335ca0f
--- /dev/null
+++ b/board/accton/as5610_52x/board.h
@@ -0,0 +1,228 @@
+/*
+ * File:        board.h
+ * Purpose:     To define the specific function call of this board.
+ *
+ * Notes:
+ * History:
+ *  2013/08/26    -- Aaron Lien, Initial version
+ *
+ * Copyright (C) 2013  Accton Corporation
+ */
+
+#ifndef __BOARD_H__
+#define __BOARD_H__
+
+/////////////////////////////////////////////////////////////////////////
+/* CPU */
+#define CONFIG_CPU_GBLUTI_BAR (CONFIG_SYS_CCSRBAR+0xE0000)
+#define CCSR_GBLUTI_PORPLLSR     CONFIG_CPU_GBLUTI_BAR
+#define CCSR_GBLUTI_PORDEVSR2    (CONFIG_CPU_GBLUTI_BAR+0x14)
+
+unsigned long get_board_sys_clk(void);
+unsigned long get_board_data_rate(void);
+
+/////////////////////////////////////////////////////////////////////////
+/* CPLD */
+#define CPLD_REG_MODEL_TYPE	  (0x00)
+#  define CPLD_PCB_VER_MASK          (0x38)
+#  define CPLD_PCB_VER_SHIFT         (0x3)
+#  define CPLD_PCB_MODEL_TYPE_MASK   (0x7)
+#  define CPLD_PCB_MODEL_TYPE_SHIFT  (0x0)
+
+#define CPLD_REG_PS2_STATUS	  (0x01)
+#define CPLD_REG_PS1_STATUS	  (0x02)
+#  define CPLD_PS_ABSENT             (1 << 0)
+#  define CPLD_PS_DC_OK              (1 << 1)
+
+#define CPLD_REG_SYSTEM_STATUS	  (0x03)
+#  define CPLD_SYS_PWR_GOOD          (1 << 0)
+#  define CPLD_SYS_FAN_ABSENT        (1 << 2)
+#  define CPLD_SYS_FAN_BAD           (1 << 3)
+#  define CPLD_SYS_FAN_AIR_FLOW      (1 << 4)
+
+#define CPLD_REG_SFP_INTR_STATUS  (0x05)
+#  define CPLD_SFP_PRESENT           (1 << 0)
+#  define CPLD_SFP_RX_LOS            (1 << 1)
+#  define CPLD_QSFP_P0_INTR          (1 << 2)
+#  define CPLD_QSFP_P1_INTR          (1 << 3)
+#  define CPLD_QSFP_P2_INTR          (1 << 4)
+#  define CPLD_QSFP_P3_INTR          (1 << 5)
+
+#define CPLD_REG_PHY00_07_INTR_STATUS  (0x06)
+#  define CPLD_PHY00_INTR            (1 << 0)
+#  define CPLD_PHY01_INTR            (1 << 1)
+#  define CPLD_PHY02_INTR            (1 << 2)
+#  define CPLD_PHY03_INTR            (1 << 3)
+#  define CPLD_PHY04_INTR            (1 << 4)
+#  define CPLD_PHY05_INTR            (1 << 5)
+#  define CPLD_PHY06_INTR            (1 << 6)
+#  define CPLD_PHY07_INTR            (1 << 7)
+
+#define CPLD_REG_PHY08_15_INTR_STATUS  (0x07)
+#  define CPLD_PHY08_INTR            (1 << 8)
+#  define CPLD_PHY09_INTR            (1 << 9)
+#  define CPLD_PHY10_INTR            (1 << 10)
+#  define CPLD_PHY11_INTR            (1 << 11)
+#  define CPLD_PHY12_INTR            (1 << 12)
+#  define CPLD_PHY13_INTR            (1 << 13)
+#  define CPLD_PHY14_INTR            (1 << 14)
+#  define CPLD_PHY15_INTR            (1 << 15)
+
+#define CPLD_REG_MISC_INTR_STATUS  (0x08)
+#  define CPLD_W83782G_INTR          (1 << 0)
+#  define CPLD_UPD720102GG_INTR      (1 << 1)
+
+#define CPLD_REG_VERSION           (0x09)
+#  define CPLD_VERSION_MASK          (0x1F)
+#  define CPLD_RELEASE_VERSION       (1 << 5)
+
+#define CPLD_REG_VMARG_CTRL_1      (0x0A)
+#  define CPLD_VMARG_1_05V_CPU_MASK    (0x3)
+#  define CPLD_VMARG_1_05V_CPU_SHIFT   (0)
+#  define CPLD_VMARG_1V_PHY1_MASK      (0xc)
+#  define CPLD_VMARG_1V_PHY1_SHIFT     (2)
+#  define CPLD_VMARG_1V_PHY2_MASK      (0x30)
+#  define CPLD_VMARG_1V_PHY3_SHIFT     (4)
+#  define CPLD_VMARG_HIGH              (3)
+#  define CPLD_VMARG_NORMAL            (2)
+#  define CPLD_VMARG_LOW               (0)
+
+#define CPLD_REG_VMARG_CTRL_2      (0x0B)
+#  define CPLD_VMARG_3_3V_MASK         (0x3)
+#  define CPLD_VMARG_3_3V_SHIFT        (0)
+#  define CPLD_VMARG_3_3V_SFP_MASK     (0xc)
+#  define CPLD_VMARG_3_3V_SFP_SHIFT    (2)
+
+#define CPLD_REG_FLASH_SWIZZLE     (0x0C)
+#  define CPLD_SWIZZLE_A22_A23         (1 << 0)
+#  define CPLD_SWIZZLE_ENABLE          (1 << 1)
+
+#define CPLD_REG_FAN_CONTROL	   (0xD)
+
+#define CPLD_REG_WATCH_DOG_CTRL    (0x0E)
+#  define CPLD_WATCH_DOG_KICK          (1 << 0)
+#  define CPLD_WATCH_DOG_ENABLE        (1 << 1)
+#  define CPLD_WATCH_DOG_COUNT_MASK    (0x3c)
+#  define CPLD_WATCH_DOG_COUNT_SHIFT   (2)
+
+#define CPLD_REG_POWER_CTRL        (0x0F)
+#  define CPLD_POWER_OT_PROTECT        (1 << 2)
+
+#define CPLD_REG_RESET_CTRL_1      (0x10) // all resets active low
+#  define CPLD_RESET_SYSTEM_L		(1 << 0)
+#  define CPLD_RESET_BCM56846_L		(1 << 1)
+#  define CPLD_RESET_BCM8475_GRP1_L	(1 << 2)
+#  define CPLD_RESET_BCM8475_GRP2_L	(1 << 3)
+#  define CPLD_RESET_W83782G_L		(1 << 4)
+
+#define CPLD_REG_RESET_CTRL_2      (0x11) // all resets active low
+#  define CPLD_RESET_BCM5482S_L		(1 << 0)
+#  define CPLD_RESET_I2C_SWITCH_L	(1 << 1)
+#  define CPLD_RESET_I2C_GPIO_L		(1 << 2)
+#  define CPLD_RESET_USB_PHY_L		(1 << 3)
+#  define CPLD_RESET_USB_HUB_L		(1 << 4)
+
+#define CPLD_REG_INTERRUPT_MASK    (0x12)
+#  define CPLD_INTR_MASK_W83782G	(1 << 0)
+#  define CPLD_INTR_MASK_BCM56846	(1 << 1)
+#  define CPLD_INTR_MASK_BCM8475	(1 << 2)
+#  define CPLD_INTR_MASK_I2C_GPIO	(1 << 3)
+#  define CPLD_INTR_MASK_USB		(1 << 4)
+#  define CPLD_INTR_MASK_CF_CARD	(1 << 5)
+#  define CPLD_INTR_MASK_WATCH_DOG	(1 << 6)
+#  define CPLD_INTR_MASK_RX_LOS		(1 << 7)
+
+#define CPLD_REG_SYSTEM_LED_CTRL_1  (0x13)
+#  define CPLD_SYS_LED_PS1_MASK		(0x03)
+#    define CPLD_SYS_LED_PS1_HW_CTRL	  (3)
+#    define CPLD_SYS_LED_PS1_GREEN	  (2)
+#    define CPLD_SYS_LED_PS1_AMBER	  (1)
+#  define CPLD_SYS_LED_PS2_MASK		(0x0c)
+#    define CPLD_SYS_LED_PS2_HW_CTRL	  (3 << 2)
+#    define CPLD_SYS_LED_PS2_GREEN	  (2 << 2)
+#    define CPLD_SYS_LED_PS2_AMBER	  (1 << 2)
+#  define CPLD_SYS_LED_DIAG_MASK	(0x30)
+#    define CPLD_SYS_LED_DIAG_AMBER_BLINK	(3 << 4)
+#    define CPLD_SYS_LED_DIAG_GREEN		(2 << 4)
+#    define CPLD_SYS_LED_DIAG_AMBER		(1 << 4)
+#    define CPLD_SYS_LED_DIAG_OFF		(0 << 4)
+#  define CPLD_SYS_LED_FAN_MASK		(0xC0)
+#    define CPLD_SYS_LED_FAN_OFF	  (3 << 6)
+#    define CPLD_SYS_LED_FAN_AMBER	  (2 << 6)
+#    define CPLD_SYS_LED_FAN_GREEN	  (1 << 6)
+
+#define CPLD_REG_MISC_CTRL	    (0x14)
+#  define CPLD_MISC_QSFP_LED_SHIFT_REG_CLEAR	(1 << 0)
+
+#define CPLD_REG_SYSTEM_LED_CTRL_2  (0x15)
+#  define CPLD_SYS_LED_LOCATOR_MASK	(0x03)
+#    define CPLD_SYS_LED_LOCATOR_GREEN_BLINK	(3)
+#    define CPLD_SYS_LED_LOCATOR_OFF		(1)
+
+u8 cpld_rd(u32 reg);
+void cpld_wr(u32 reg, u8 data);
+
+/////////////////////////////////////////////////////////////////////////
+/* I2C */
+#define I2C_CHANNEL_1               0x00
+#define I2C_CHANNEL_2               0x01
+
+/* I2C bus switch */
+#define I2C_ADDR_PCA9548            0x70
+#define I2C_ADDR_PCA9548_SFP        0x74
+#define I2C_ADDR_PCA9546_1          0x75
+#define I2C_ADDR_PCA9546_2          0x76
+#define I2C_ADDR_PCA9546_3          0x77
+
+/* channel 1 devices */
+#define I2C_ADDR_W83782G            0x29
+#define I2C_ADDR_RTC8564            0x51
+#define I2C_ADDR_NE1617A_1          0x4C
+#define I2C_ADDR_NE1617A_2          0x1A
+#define I2C_ADDR_NE1617A_3          0x18
+#define I2C_ADDR_EEPROM_PSU         0x50
+#define I2C_ADDR_SMSC_USB2513       0x2C
+#define I2C_ADDR_VT1165M            0x71
+#define I2C_ADDR_ICS9DB803          0x6E
+
+/* channel 2 devices */
+#define I2C_ADDR_SFP                0x50
+#define I2C_ADDR_QSFP_0             0x10
+#define I2C_ADDR_QSFP_1             0x14
+#define I2C_ADDR_QSFP_2             0x18
+#define I2C_ADDR_QSFP_3             0x1C
+#define I2C_ADDR_PCA9506_1          0x20
+#define I2C_ADDR_PCA9506_2          0x21
+#define I2C_ADDR_PCA9506_3          0x20
+#define I2C_ADDR_PCA9506_4          0x22
+#define I2C_ADDR_PCA9538_1          0x72
+#define I2C_ADDR_PCA9538_2          0x73
+#define I2C_ADDR_PCA9538_3          0x71
+#define I2C_ADDR_PCA9538_4          0x70
+#define I2C_ADDR_PCA9538_5          0x71
+#define I2C_ADDR_PCA9538_6          0x73
+#define I2C_ADDR_PCA9538_7          0x72
+#define I2C_ADDR_EQ_DS100KR800      0x64
+
+
+#define I2C_RTC8564_REG_CTRL1       0x00
+#define I2C_RTC8564_REG_SEC         0x02
+#define I2C_RTC8564_REG_MIN         0x03
+#define I2C_RTC8564_REG_HOUR        0x04
+#define I2C_RTC8564_REG_DAY         0x05
+#define I2C_RTC8564_REG_WEEK        0x06
+#define I2C_RTC8564_REG_MON         0x07
+#define I2C_RTC8564_REG_YEAR        0x08
+#define I2C_RTC8564_MASK_SEC        0x7F
+#define I2C_RTC8564_MASK_MIN        0x7F
+#define I2C_RTC8564_MASK_HOUR       0x3F
+#define I2C_RTC8564_MASK_DAY        0x3F
+#define I2C_RTC8564_MASK_WEEK       0x07
+#define I2C_RTC8564_MASK_MON        0x1F
+#define I2C_RTC8564_MASK_YEAR       0xFF
+
+/////////////////////////////////////////////////////////////////////////
+/* FAN */
+#define DEFAULT_FAN_DUTY_CYCLE 100
+
+#endif /* __BOARD_H__ */
diff --git a/board/accton/as5610_52x/bootf.c b/board/accton/as5610_52x/bootf.c
new file mode 100644
index 0000000..72b40b1
--- /dev/null
+++ b/board/accton/as5610_52x/bootf.c
@@ -0,0 +1,54 @@
+/*
+* File:        bootf.c
+* Purpose:     To boot the fastpath application image.
+*
+* Notes:
+* History:
+*  2012/03/08    -- Aaron Lien, Initial version
+*
+* Copyright (C) 2012  Accton Corporation & authors.
+*/
+#include <common.h>
+#include "fastpath.h"
+
+
+/* STK image = {STK header + uImage}*/
+static int do_bootf(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+    char * local_argv[3];
+    ulong	addr;
+    char str_addr[30], tmp[30];
+    stkFileHeader_t *header;
+
+    /* <addr> */
+    addr = CONFIG_SYS_LOAD_ADDR;		/* Default Load Address */
+    if(argc >= 2)
+        addr = simple_strtoul(argv[1], NULL, 16);
+
+    header = (stkFileHeader_t *)addr;
+
+    addr += header->stk_header_size;    /* uImage start address */
+    sprintf(str_addr, "0x%08lX", addr);
+
+    /* <fdt#> */
+    if(argc >=3)
+        sprintf(tmp, "-f%s", argv[2]);
+    else
+        sprintf(tmp, "-f%d", CONFIG_FDT_INDEX);
+
+    /* <ex.> bootm 0x1000074 -f<fdt#> */
+    local_argv[0] = "bootm";
+    local_argv[1] = str_addr;
+    local_argv[2] = tmp;
+
+    return do_bootm(NULL, 0, 3, local_argv);
+}
+
+U_BOOT_CMD(
+    bootf, CONFIG_SYS_MAXARGS, 1,	do_bootf,
+    "bootf\t- boot FASTPATH application image from memory.",
+    "[<addr> [<fdt#>]] - boot FASTPATH application image stored in memory.\n"
+    "\taddr: image address in memory.\n"
+    "\tfdt#: image# of flat device tree in FASTPATH image.\n"
+    "\n\tThe default fdt# is 4 which indicates the fdt is at image#4."
+);
diff --git a/board/accton/as5610_52x/cmd_dram_test.c b/board/accton/as5610_52x/cmd_dram_test.c
new file mode 100644
index 0000000..8b3c4c7
--- /dev/null
+++ b/board/accton/as5610_52x/cmd_dram_test.c
@@ -0,0 +1,489 @@
+#include <common.h>
+#include <command.h>
+
+#define diag_printf printf
+
+/**************************************************************
+ * diag_mem
+ *************************************************************/
+#define DIAG_MEM_TOTAL_SIZE         (0x80000000UL)
+#define DIAG_MEM_BASE_ADDR          (0x0UL)
+#define DIAG_MEM_MAX_ADDR           (DIAG_MEM_BASE_ADDR + DIAG_MEM_TOTAL_SIZE)
+
+#define DIAG_MEM_ADDRESS_ALIGN_WORD (4UL)
+#define DIAG_MEM_BACKUP_BUF_SIZE    (128UL*1024UL)
+
+#define DIAG_MEM_PATTERN_FIVE       (0x55555555UL)
+#define DIAG_MEM_PATTERN_ALPHA      (0xAAAAAAAAUL)
+
+static char diag_mem_backup_buf[DIAG_MEM_BACKUP_BUF_SIZE];
+static int last_percent = 0;
+static ulong timer_keep = 0;
+static ulong timer_change = 0;
+void show_progress(ulong startAddr, ulong endAddr, ulong currentAddr)
+{
+	ulong current_timer = get_timer(0);
+	//printf("%08X",currentAddr);
+	if((current_timer - timer_keep) > timer_change)
+	{
+		int percent = ((currentAddr - startAddr)) / (((endAddr-startAddr))/100);
+		if(percent != last_percent || (current_timer - timer_keep) > 1000)
+		{
+			printf("\r%08X : %d%%",currentAddr,percent);
+			last_percent = percent;
+
+			if(timer_change == 0)
+			{
+				timer_change = (current_timer - timer_keep);//first timer range
+			}
+
+			timer_keep = current_timer;
+		}
+	}
+}
+
+int diagMemAddressBusTest(ulong startAddr, ulong endAddr)
+{
+    register ulong blockStartAddr;
+    register ulong blockSize;
+
+    register ulong pattern     = (ulong) DIAG_MEM_PATTERN_ALPHA;
+    register ulong antipattern = (ulong) DIAG_MEM_PATTERN_FIVE;
+
+    register ulong currAddr;
+    register ulong* ptrBackup;
+
+    register ulong ret = 0;
+	register ulong errorAddr = 0;
+
+    for(blockStartAddr=startAddr; blockStartAddr<endAddr; blockStartAddr+=DIAG_MEM_BACKUP_BUF_SIZE)
+    {
+        if(endAddr-blockStartAddr > DIAG_MEM_BACKUP_BUF_SIZE)
+        {
+            blockSize = DIAG_MEM_BACKUP_BUF_SIZE;
+        }
+        else
+        {
+            blockSize = endAddr-blockStartAddr;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip U-boot, might be protected*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            *ptrBackup = *((ulong*)currAddr);
+
+            *((ulong*)currAddr) = pattern;
+        }
+
+        //ptrBackup = (ulong*)diag_mem_backup_buf;	/*Kenny Cheng remove*/
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4)//, ptrBackup++) /*Kenny Cheng Remove */
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip U-boot, might be protected*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            if( pattern != *((ulong*)currAddr) )
+            {
+				errorAddr = currAddr;
+                ret++;
+            }
+
+            *((ulong*)currAddr) = antipattern;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip U-boot, might be protected*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            if( antipattern != *((ulong*)currAddr) )
+            {
+				errorAddr = currAddr;
+                ret++;
+            }
+
+            *((ulong*)currAddr) = *ptrBackup;
+        }
+
+        if(ctrlc())
+        {
+            return -1;
+        }
+		else
+		{
+			/*show_progress(startAddr,endAddr,currAddr);*/
+		}
+    }
+
+	/*show_progress(startAddr,endAddr,blockStartAddr);*/
+
+    if(ret != 0)
+	{
+		diag_printf("errorAddr = 0x%08X\n",errorAddr);
+        return -1;
+    }
+	else
+        return 0;
+}
+
+int diagMemDataBusTest(ulong startAddr, ulong endAddr)
+{
+    register ulong currAddr;
+    register ulong backup;
+    register ulong pattern;
+
+    /* Data Bust Test */
+    for(currAddr=startAddr; currAddr<endAddr; currAddr+=4)
+    {
+		if( (currAddr >= 0)
+         && (currAddr < 0x1000) )
+        {
+              continue;
+        }
+
+        if( (currAddr >= (ulong)(diagMemDataBusTest))
+            && (currAddr < (ulong)(0x1000+diagMemDataBusTest)) )
+        {
+            continue;
+        }
+
+        /* Perform a walking 1's test at the given address. */
+        for(pattern=1; pattern!=0; pattern<<=1)
+        {
+            backup = *((ulong*)currAddr);
+
+            /* Write the test pattern. */
+            *((ulong*)currAddr) = pattern;
+
+            /* Read it back (immediately is okay for this test). */
+            if(*((ulong*)currAddr) != pattern)
+            {
+                *((ulong*)currAddr) = backup;
+
+                diag_printf("(pattern = 0x%08X)...", pattern);
+                return -1;
+            }
+
+            *((ulong*)currAddr) = backup;
+        }
+
+        if(ctrlc())
+        {
+            return -1;
+        }
+		else
+		{
+				/*show_progress(startAddr,endAddr,currAddr);*/
+		}
+    }
+
+	/*show_progress(startAddr,endAddr,currAddr);*/
+
+    return 0;
+}
+
+int do_diag_dram_func(ulong startAddr, ulong endAddr)
+{
+    ulong temp;
+
+    /* address alignment */
+    startAddr -= (startAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    endAddr -= (endAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    //startAddr = (startAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+    //endAddr = (endAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+
+    diag_printf("START Address: 0x%08X\n", startAddr);
+    diag_printf("END Address: 0x%08X\n", endAddr);
+	last_percent = 0;
+	timer_change = 0;
+	timer_keep = get_timer(0);
+    diag_printf("Data Bus Test...\n");
+
+    if(diagMemDataBusTest(startAddr, endAddr) == 0)
+    {
+        diag_printf("\r%08x~%08x 100%% OK!\n",startAddr,endAddr);
+    }
+    else
+    {
+        diag_printf("FAIL!\n");
+	return -2;
+    }
+
+    last_percent = 0;
+    timer_change = 0;
+	timer_keep = get_timer(0);
+    diag_printf("Address Bus Test...\n");
+
+    if(diagMemAddressBusTest(startAddr, endAddr) == 0)
+    {
+        diag_printf("\r%08x~%08x 100%% OK!\n",startAddr,endAddr);
+    }
+    else
+    {
+        diag_printf("FAIL!\n");
+	return -3;
+    }
+
+	return 0;
+
+
+}
+
+int do_diag_dram_func_quick(ulong startAddr, ulong endAddr)
+{
+	register ulong blockStartAddr;
+    register ulong blockSize;
+
+    register ulong currAddr;
+    register ulong* ptrBackup;
+
+    register ulong ret = 0;
+	register ulong errorAddr = 0;
+
+    /* alignment */
+    startAddr -= (startAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    endAddr -= (endAddr % DIAG_MEM_ADDRESS_ALIGN_WORD);
+    //startAddr = (startAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+    //endAddr = (endAddr & ~(DIAG_MEM_ADDRESS_ALIGN_WORD-1));
+
+    for(blockStartAddr=startAddr; blockStartAddr<endAddr; blockStartAddr+=DIAG_MEM_BACKUP_BUF_SIZE)
+    {
+        if(endAddr-blockStartAddr > DIAG_MEM_BACKUP_BUF_SIZE)
+        {
+            blockSize = DIAG_MEM_BACKUP_BUF_SIZE;
+        }
+        else
+        {
+            blockSize = endAddr-blockStartAddr;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+	    if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+	    if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip diag log area*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            *ptrBackup = *((ulong*)currAddr);
+
+            *((ulong*)currAddr) = 0xAAAAAAAA;
+        }
+
+        ptrBackup = (ulong*)diag_mem_backup_buf;
+        for(currAddr=blockStartAddr; currAddr<blockStartAddr+blockSize; currAddr+=4, ptrBackup++)
+        {
+			if( (currAddr >= 0)
+                && (currAddr < 0x1000) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diagMemAddressBusTest))
+                && (currAddr < (ulong)(0x1000+diagMemAddressBusTest)) )
+            {
+                continue;
+            }
+
+            if( (currAddr >= (ulong)(diag_mem_backup_buf))
+                && (currAddr < (ulong)(DIAG_MEM_BACKUP_BUF_SIZE+diag_mem_backup_buf)) )
+            {
+                continue;
+            }
+
+			if( (currAddr >= (ulong)(0x7Fd00000)) 	/*Skip diag log area*/
+                && (currAddr < (ulong)(0x80000000)) )
+            {
+                continue;
+            }
+
+            if( 0xAAAAAAAA != *((ulong*)currAddr) )
+            {
+				errorAddr = currAddr;
+                ret++;
+            }
+
+            *((ulong*)currAddr) = *ptrBackup;
+        }
+
+        if(ctrlc())
+        {
+            return -1;
+        }
+		else
+		{
+			//diag_printf("\r%08X : %d%%",blockStartAddr,((blockStartAddr - startAddr)) / (((endAddr-startAddr))/100));
+		}
+    }
+
+	//diag_printf("\r%08X : %d%%",blockStartAddr,((blockStartAddr - startAddr)) / (((endAddr-startAddr))/100));
+
+    if(ret != 0)
+	{
+		diag_printf("\rerrorAddr = 0x%08X\n",errorAddr);
+        return -1;
+    }
+	else
+	{
+		diag_printf("\r%08X~%08X 100%% OK!\n",startAddr,endAddr);
+        return 0;
+	}
+}
+
+int do_diag_dram_cmd(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    ulong start = 0;
+    ulong end = 0;
+    int ret = 0;
+	ulong time_start = get_timer(0);
+    ulong time_end = 0;
+
+    if(argc < 3)
+    {
+        diag_printf("Usage:\n%s\n", cmdtp->usage);
+        return -1;
+    }
+	else if(argc >= 4)
+	{
+		if(strcmp("full",argv[3]) == 0)
+		{
+			start = simple_strtoul(argv[1], NULL, 16);
+			end = simple_strtoul(argv[2], NULL, 16);
+
+			if( start>DIAG_MEM_MAX_ADDR || end>DIAG_MEM_MAX_ADDR || start>=end)
+			{
+				diag_printf("invalid range");
+				return -1;
+			}
+
+			ret = do_diag_dram_func(start, end);
+		}
+		else
+		{
+			diag_printf("Usage:\n%s\n", cmdtp->usage);
+			return -1;
+		}
+	}
+	else
+	{
+		start = simple_strtoul(argv[1], NULL, 16);
+		end = simple_strtoul(argv[2], NULL, 16);
+
+		if( start>DIAG_MEM_MAX_ADDR || end>DIAG_MEM_MAX_ADDR || start>=end)
+		{
+			diag_printf("invalid range");
+			return -1;
+		}
+
+		ret = do_diag_dram_func_quick(start, end);
+	}
+
+
+    if(ret == 0)
+    {
+        diag_printf("DRAM test Success!\n");
+    }
+    else
+    {
+        diag_printf("DRAM test Fail!\n");
+    }
+
+	time_end = get_timer(0);
+	diag_printf("\nTime spend = %dms\n",time_end-time_start);
+	return ret;
+}
+
+U_BOOT_CMD(
+    dram_test, 4, 0, do_diag_dram_cmd,
+    "memory test from startAddr to endAddr",
+    "dram_test <startAddr> <endAddr> [full]\n"
+    "Syntax:\n"
+    "    diag_dram <startAddr> <endAddr> [full]\n"
+    "Example:\n"
+    "    diag_dram 0x2000 0x1ffffffc\n"
+);
diff --git a/board/accton/as5610_52x/ddr.c b/board/accton/as5610_52x/ddr.c
new file mode 100644
index 0000000..3e0924d
--- /dev/null
+++ b/board/accton/as5610_52x/ddr.c
@@ -0,0 +1,279 @@
+/*
+ * Copyright 2009-2010 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+#include <asm/immap_85xx.h>
+#include <asm/processor.h>
+#include <asm/fsl_ddr_sdram.h>
+#include <asm/io.h>
+#include <asm/fsl_law.h>
+#include "board.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+extern void fsl_ddr_set_memctl_regs(const fsl_ddr_cfg_regs_t *regs,
+				   unsigned int ctrl_num);
+
+#define DATARATE_400MHZ 400000000
+#define DATARATE_533MHZ 533333333
+#define DATARATE_667MHZ 666666666
+#define DATARATE_800MHZ 800000000
+
+#if 0
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000007F /*DDR3 1G -> 3F , 2G -> 7F , susan add */
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80044302 /*80044302 changed*/
+#define CONFIG_SYS_DDR_CS0_CONFIG_2	0x00000000
+
+#define CONFIG_SYS_DDR_CONTROL		0xe7000000	/* offset = 110*/
+#define CONFIG_SYS_DDR_CONTROL_2		0x24401011	/* offset = 114*/
+#define CONFIG_SYS_DDR_MODE_CONTROL	0x00000000    /* offset = 120*/
+#define CONFIG_SYS_DDR_INIT_ADDR		0x00000000    /* offset = 148*/
+#define CONFIG_SYS_DDR_INIT_EXT_ADDR	0x00000000	/* offset = 14C*/
+
+#define CONFIG_SYS_DDR_TIMING_4		0x00220001	/* offset = 160*/
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400	/* offset = 164*/
+
+#define CONFIG_SYS_DDR_ZQ_CONTROL	0x00000000	/* offset = 170*/
+#define CONFIG_SYS_DDR_WRLVL_CONTROL	0x8645F607	/* offset = 174*/
+#define CONFIG_SYS_DDR_SR_CNTR		0x00000000
+#define CONFIG_SYS_DDR_RCW_1			0x00000000    /* offset = 180*/
+#define CONFIG_SYS_DDR_RCW_2			0x00000000	/* offset = 184*/
+
+#define CONFIG_SYS_DDR_WRLVL_CONTROL2	0x0	/* offset = 190*/
+#define CONFIG_SYS_DDR_WRLVL_CONTROL3	0x0    /* offset = 194*/
+
+#define CONFIG_SYS_DDR_ERR_INJECT_HI	0x0           /*0xe00*/
+
+
+#define CONFIG_SYS_DDR_TIMING_3_400	0x00010000
+#define CONFIG_SYS_DDR_TIMING_0_400	0x00260802
+#define CONFIG_SYS_DDR_TIMING_1_400	0x39355322
+#define CONFIG_SYS_DDR_TIMING_2_400	0x1f9048ca
+#define CONFIG_SYS_DDR_CLK_CTRL_400	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_400	0x00480432
+#define CONFIG_SYS_DDR_MODE_2_400	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_400	0x06180100
+
+#define CONFIG_SYS_DDR_TIMING_3_533	0x00020000
+#define CONFIG_SYS_DDR_TIMING_0_533	0x00260802
+#define CONFIG_SYS_DDR_TIMING_1_533	0x4c47c432
+#define CONFIG_SYS_DDR_TIMING_2_533	0x0f9848ce
+#define CONFIG_SYS_DDR_CLK_CTRL_533	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_533	0x00040642
+#define CONFIG_SYS_DDR_MODE_2_533	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_533	0x08200100
+
+#if 0
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x55770802
+#define CONFIG_SYS_DDR_TIMING_1_667	0x5f599543
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0fa074d1
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x03000000
+#define CONFIG_SYS_DDR_MODE_1_667	0x00040852
+#define CONFIG_SYS_DDR_MODE_2_667	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0a280100
+#else
+/* for ES5652BT1 R01A~R01D, SYSCLK=66.67MHz/83.3MHz */
+#define CONFIG_SYS_DDR_TIMING_3_667	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_667	0x003a0104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x6f6b0644
+#define CONFIG_SYS_DDR_TIMING_2_667	0x0FA888d0
+
+#define CONFIG_SYS_DDR_MODE_1_667	0x00421222 /*offset=0x118*/
+#define CONFIG_SYS_DDR_MODE_2_667	0x04000000 /*offset=0x11C*/
+#define CONFIG_SYS_DDR_INTERVAL_667	0x0A280100 /*offset=0x124*/
+#define CONFIG_SYS_DDR_CLK_CTRL_667	0x02000000 /*offset=0x130*/
+#endif
+
+#if 0
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00040000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x55770802
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6b6543
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0fa074d1
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02800000
+#define CONFIG_SYS_DDR_MODE_1_800	0x00040852
+#define CONFIG_SYS_DDR_MODE_2_800	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0a280100
+#else
+/* for ES5652BT1 R01E, SYSCLK=100MHz */
+#define CONFIG_SYS_DDR_TIMING_3_800	0x00030000
+#define CONFIG_SYS_DDR_TIMING_0_800	0x003a0104
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6bf644
+#define CONFIG_SYS_DDR_TIMING_2_800	0x0FA888d0
+#define CONFIG_SYS_DDR_MODE_1_800	0x00421222 /*offset=0x118*/
+#define CONFIG_SYS_DDR_MODE_2_800	0x04000000 /*offset=0x11C*/
+#define CONFIG_SYS_DDR_INTERVAL_800	0x0A280100 /*offset=0x124*/
+#define CONFIG_SYS_DDR_CLK_CTRL_800	0x02000000 /*offset=0x130*/
+
+#endif
+#else
+////////////////
+#define CONFIG_SYS_DDR_CS0_BNDS		0x0000007F
+#define CONFIG_SYS_DDR_CS0_CONFIG	0x80044302
+#define CONFIG_SYS_DDR_TIMING_3		0x00030000
+#define CONFIG_SYS_DDR_TIMING_0		0x003a0104
+#define CONFIG_SYS_DDR_TIMING_1_667	0x6f6bF644	/*6f6b0644 can't work on 83.3MHz sysclock*/     /* DDR data rate = 667MHz */
+#define CONFIG_SYS_DDR_TIMING_1_800	0x6f6bf644      /* DDR data rate = 800MHz */
+#define CONFIG_SYS_DDR_TIMING_2		0x0fa888d0
+#define CONFIG_SYS_DDR_MODE_1		0x00441422
+#define CONFIG_SYS_DDR_MODE_2		0x04000000
+#define CONFIG_SYS_DDR_MODE_CTRL	0x00000000
+#define CONFIG_SYS_DDR_INTERVAL		0x0a280100
+#define CONFIG_SYS_DDR_DATA_INIT	0xDEADBEEF
+#define CONFIG_SYS_DDR_CLK_CTRL		0x02000000
+#define CONFIG_SYS_DDR_TIMING_4		0x00220001
+#define CONFIG_SYS_DDR_TIMING_5		0x03402400
+#define CONFIG_SYS_DDR_ZQ_CNTL		0x00000000 /* double check */
+#define CONFIG_SYS_DDR_WRLVL_CNTL	0x8645F605
+#define CONFIG_SYS_DDR_CONTROL		0xE7000008 /* ECC enable, Type = DDR3 */
+#define CONFIG_SYS_DDR_CONTROL_2	0x24401010
+#define CONFIG_SYS_DDR_CDR1		0x00040000
+#define CONFIG_SYS_DDR_CDR2		0x00000000
+#define CONFIG_SYS_DDR_ERR_INT_EN	0x00000000
+#define CONFIG_SYS_DDR_ERR_DIS		0x00000000
+#define CONFIG_SYS_DDR_SBE		0x00000000 /* should be 0x00010000 */
+
+#endif
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_667 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_667,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CTRL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL,
+	.ddr_data_init = CONFIG_SYS_DDR_DATA_INIT,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CNTL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CNTL,
+	.ddr_cdr1 = CONFIG_SYS_DDR_CDR1,
+    .ddr_cdr2 = CONFIG_SYS_DDR_CDR2,
+    .err_int_en = CONFIG_SYS_DDR_ERR_INT_EN,
+    .err_disable = CONFIG_SYS_DDR_ERR_DIS
+};
+
+fsl_ddr_cfg_regs_t ddr_cfg_regs_800 = {
+	.cs[0].bnds = CONFIG_SYS_DDR_CS0_BNDS,
+	.cs[0].config = CONFIG_SYS_DDR_CS0_CONFIG,
+	.timing_cfg_3 = CONFIG_SYS_DDR_TIMING_3,
+	.timing_cfg_0 = CONFIG_SYS_DDR_TIMING_0,
+	.timing_cfg_1 = CONFIG_SYS_DDR_TIMING_1_800,
+	.timing_cfg_2 = CONFIG_SYS_DDR_TIMING_2,
+	.ddr_sdram_cfg = CONFIG_SYS_DDR_CONTROL,
+	.ddr_sdram_cfg_2 = CONFIG_SYS_DDR_CONTROL_2,
+	.ddr_sdram_mode = CONFIG_SYS_DDR_MODE_1,
+	.ddr_sdram_mode_2 = CONFIG_SYS_DDR_MODE_2,
+	.ddr_sdram_md_cntl = CONFIG_SYS_DDR_MODE_CTRL,
+	.ddr_sdram_interval = CONFIG_SYS_DDR_INTERVAL,
+	.ddr_data_init = CONFIG_SYS_DDR_DATA_INIT,
+	.ddr_sdram_clk_cntl = CONFIG_SYS_DDR_CLK_CTRL,
+	.timing_cfg_4 = CONFIG_SYS_DDR_TIMING_4,
+	.timing_cfg_5 = CONFIG_SYS_DDR_TIMING_5,
+	.ddr_zq_cntl = CONFIG_SYS_DDR_ZQ_CNTL,
+	.ddr_wrlvl_cntl = CONFIG_SYS_DDR_WRLVL_CNTL,
+	.ddr_cdr1 = CONFIG_SYS_DDR_CDR1,
+    .ddr_cdr2 = CONFIG_SYS_DDR_CDR2,
+    .err_int_en = CONFIG_SYS_DDR_ERR_INT_EN,
+    .err_disable = CONFIG_SYS_DDR_ERR_DIS
+};
+
+/*
+ * Fixed sdram init -- doesn't use serial presence detect.
+ */
+
+phys_size_t fixed_sdram (void)
+{
+	sys_info_t sysinfo;
+	unsigned long ddr_data_rate;
+	char buf[32];
+	fsl_ddr_cfg_regs_t ddr_cfg_regs;
+	phys_size_t ddr_size;
+	struct cpu_type *cpu;
+
+	get_sys_info(&sysinfo);
+
+        ddr_data_rate = sysinfo.freqDDRBus;
+
+	printf("fixed_sdram Configuring DDR for %s MT/s data rate\n",
+				strmhz(buf, ddr_data_rate));
+
+	if(ddr_data_rate <= DATARATE_667MHZ)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_667, sizeof(ddr_cfg_regs));
+	else if(ddr_data_rate <= DATARATE_800MHZ)
+		memcpy(&ddr_cfg_regs, &ddr_cfg_regs_800, sizeof(ddr_cfg_regs));
+	else
+		panic("Unsupported DDR data rate %s MT/s data rate\n",
+					strmhz(buf, ddr_data_rate));
+
+
+	cpu = gd->cpu;
+	ddr_size = CONFIG_SYS_SDRAM_SIZE * (1UL<<20);
+
+
+	fsl_ddr_set_memctl_regs(&ddr_cfg_regs, 0);
+
+    /* DDR LAW */
+	if (set_ddr_laws(CONFIG_SYS_DDR_SDRAM_BASE,
+			 CONFIG_SYS_SDRAM_SIZE * (1U<<20),
+			 LAW_TRGT_IF_DDR) < 0) {
+		printf("ERROR setting Local Access Windows for DDR\n");
+		return 0;
+	};
+
+
+	return ddr_size;
+}
+
+#if 0
+phys_size_t initdram(int board_type)
+{
+	phys_size_t dram_size = 0;
+	struct cpu_type *cpu;
+#if defined(CONFIG_SYS_RAMBOOT) && defined(CONFIG_SYS_FSL_BOOT_DDR)
+	cpu = gd->cpu;
+	/* P1020 and it's derivatives support max 32bit DDR width */
+	if (cpu->soc_ver == SVR_P1020 || cpu->soc_ver == SVR_P1020_E ||
+		cpu->soc_ver == SVR_P1011 || cpu->soc_ver == SVR_P1011_E)
+		return (CONFIG_SYS_SDRAM_SIZE * 1024 * 1024) / 2;
+	else
+		return CONFIG_SYS_SDRAM_SIZE * 1024 * 1024;
+#endif
+	dram_size = fixed_sdram();
+
+	set_ddr_laws(0, dram_size, LAW_TRGT_IF_DDR_1);
+
+	dram_size = setup_ddr_tlbs(dram_size / 0x100000);
+	dram_size *= 0x100000;
+
+	puts("DDR: ");
+	return dram_size;
+}
+#endif
diff --git a/board/accton/as5610_52x/eq.c b/board/accton/as5610_52x/eq.c
new file mode 100644
index 0000000..4008918
--- /dev/null
+++ b/board/accton/as5610_52x/eq.c
@@ -0,0 +1,238 @@
+
+#include <common.h>
+#include <command.h>
+#include "board.h"
+
+/* EQ - Texas Instruments DS100KR800 initial value, with using DAC cable. */
+#define EQ_DAC_TBL_SIZE     9
+uchar EQ_DAC_Table[EQ_DAC_TBL_SIZE][2] = {
+    /* offset, value */
+    {0x06, 0x18},
+    {0x0F, 0x00},
+    {0x16, 0x00},
+    {0x1D, 0x00},
+    {0x24, 0x00},
+    {0x2C, 0x00},
+    {0x33, 0x00},
+    {0x3A, 0x00},
+    {0x41, 0x00}
+};
+
+static int TI_DS100KR800_init(uchar *EQ_tbl, int n);
+static int do_eq_init(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+
+extern int i2c_set_bus_num(unsigned int bus);
+extern int i2c_probe(uchar chip);
+extern int i2c_write(u8 dev, uint addr, int alen, u8 *data, int length);
+extern int i2c_read(u8 dev, uint addr, int alen, u8 *data, int length);
+
+
+
+/* Init Equalizer: DS100KR800 */
+int board_init_eq(void)
+{
+    uchar channel =0x01, value;
+
+    i2c_set_bus_num(I2C_CHANNEL_2);
+
+    if(i2c_probe(0x75) != 0){
+        printf("error, PCA9546A_1 not present\n");
+        return -1;
+    }
+
+    i2c_write(I2C_ADDR_PCA9546_1, 0, 1, &channel, 1);
+
+    udelay(11000);
+    if (i2c_probe(I2C_ADDR_PCA9548_SFP) != 0){
+        printf("error, PCA9548A_1 not present\n");
+        return -1;
+    }
+
+    i2c_write(I2C_ADDR_PCA9548_SFP, 0, 1, &channel, 1);
+    udelay(11000);
+
+    if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("error, EQ1 not present\n");
+        return -1;
+    }
+
+    value = 0x03;
+    i2c_write(I2C_ADDR_EQ_DS100KR800, 0x0f, 1, &value, 1);
+
+    return 0;
+}
+
+/* Init one EQ device */
+static int TI_DS100KR800_init(uchar *EQ_tbl, int n)
+{
+    int i;
+    uchar addr, val;
+
+    for(i=0; i < n; i++){
+        addr = *(EQ_tbl + i*2);
+        val = *(EQ_tbl + i*2 +1);
+        debug("%02x, %02x\n", addr, val);
+        i2c_write(I2C_ADDR_EQ_DS100KR800, addr, 1, &val, 1);
+        udelay(10000);
+    }
+
+    return 0;
+}
+
+/* Init all EQ, with using DAC cable. */
+int board_init_all_EQ_DAC(void)
+{
+    uchar val;
+    int ret=0;
+
+    i2c_set_bus_num(I2C_CHANNEL_2); /* channel #2 */
+
+    /* EQ_0 */
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9546_1,0,1,&val,1);
+    udelay(1000);
+
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9548_SFP,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+
+    /* EQ_1 */
+    val= 0x02;
+    i2c_write(I2C_ADDR_PCA9546_1,0,1,&val,1);
+    udelay(1000);
+
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9548_SFP,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+    /* EQ_2 */
+    val= 0x04;
+    i2c_write(I2C_ADDR_PCA9546_1,0,1,&val,1);
+    udelay(1000);
+
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9548_SFP,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+    /* EQ_3 */
+    val= 0x08;
+    i2c_write(I2C_ADDR_PCA9546_1,0,1,&val,1);
+    udelay(1000);
+
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9548_SFP,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+    /* EQ_4 */
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9546_2,0,1,&val,1);
+    udelay(1000);
+
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9548_SFP,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+    /* EQ_5 */
+    val= 0x02;
+    i2c_write(I2C_ADDR_PCA9546_2,0,1,&val,1);
+    udelay(1000);
+
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9548_SFP,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+
+    /* EQ_6 */
+    val= 0x01;
+    i2c_write(I2C_ADDR_PCA9546_3,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+    /* EQ_7 */
+    val= 0x04;
+    i2c_write(I2C_ADDR_PCA9546_3,0,1,&val,1);
+    udelay(1000);
+
+	if (i2c_probe(I2C_ADDR_EQ_DS100KR800) != 0){
+        printf("[Error] Cannot find EQ_0 device, slave address = 0x%02X\n", I2C_ADDR_EQ_DS100KR800);
+        ret = -1;
+    }else{
+        TI_DS100KR800_init((uchar *)EQ_DAC_Table, EQ_DAC_TBL_SIZE);
+    }
+
+    return ret;
+}
+
+
+static int do_eq_init(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+    if(argc != 2){
+        cmd_usage(cmdtp);
+        return -1;
+    }
+
+    if(strcmp(argv[1], "DAC") == 0)
+        board_init_all_EQ_DAC();
+
+    if(strcmp(argv[1], "FIBER") == 0)
+        printf("TBD\n");
+
+    return 0;
+}
+
+
+U_BOOT_CMD(
+    eq_init, CONFIG_SYS_MAXARGS, 1,	do_eq_init,
+    "Initialize Equalizer",
+    "<DAC | FIBER>\n"
+);
diff --git a/board/accton/as5610_52x/fastpath.h b/board/accton/as5610_52x/fastpath.h
new file mode 100644
index 0000000..9fcfa95
--- /dev/null
+++ b/board/accton/as5610_52x/fastpath.h
@@ -0,0 +1,54 @@
+/*
+* File:        fastpath.h
+* Purpose:     Fastpath boot image data structure.
+*
+* Notes:
+* History:
+*  2013/08/23    -- Aaron Lien, Initial version
+*
+* Copyright (C) 2013  Accton Corporation & authors.
+*/
+
+#ifndef __FASTPATH_
+#define __FASTPATH_
+
+#define DIM_MAX_BOOTCFG_LINE_SIZE       128
+#define DIM_MAX_FILENAME_SIZE           40
+
+/* boot Image descriptor. Each Image is described as below */
+typedef struct _dim_image
+{
+    /* Mandatory information */
+    char    currentState[15];                   /* active / backup */
+    char    nextState[15];                      /* active / backup */
+    char    fileName[DIM_MAX_FILENAME_SIZE];    /* on the fs */
+    char    numErrors[5];           /* Num of tries w/ errors    */
+    char    descr[DIM_MAX_BOOTCFG_LINE_SIZE]; /* text description */
+} dimImageInfo_t;
+
+
+/* STK image header */
+typedef struct stkFileHeader_s{
+ unsigned short crc;
+ unsigned short tag1;
+ unsigned long tag2;
+
+ unsigned long num_components; /* Number of OPR and tgz files in the STK image (may be 0) */
+
+ unsigned long file_size; /* Total number of bytes in the STK file */
+
+ unsigned char rel;
+ unsigned char ver;
+ unsigned char maint_level;
+ unsigned char build_num;
+
+ unsigned long stk_header_size; /* Number of bytes in the STk header */
+
+ unsigned char reserved[64];    /* Reserved for future use */
+
+}stkFileHeader_t;
+
+#define STK_TAG1    0xAA55
+#define STK_TAG2    0x2288BB66
+
+#endif  /* __FASTPATH_ */
diff --git a/board/accton/as5610_52x/law.c b/board/accton/as5610_52x/law.c
new file mode 100644
index 0000000..8b8d590
--- /dev/null
+++ b/board/accton/as5610_52x/law.c
@@ -0,0 +1,50 @@
+/*
+ * Copyright 2008-2010 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/fsl_law.h>
+#include <asm/mmu.h>
+
+
+/*
+ * LAW(Local Access Window) configuration:
+ *
+ * 0  LAW0  FLASH                     0xefc0_0000~0xefff_ffff	     4 Mbyte
+ * 1  LAW1  CPLD		      0xea00_0000~0xea00_00FF	     < 4K
+ * 2  LAW2  PCIe1 MEM		      0xa000_0000~0xbfff_ffff	     512 MByte
+ * 3  LAW3  PCIe1 IO		      0xffc2_0000~0xffc2_ffff	     64 K
+ *
+ * Notes:
+ *    CCSRBAR and L2-as-SRAM don't need a configured Local Access Window.
+ *    If flash is 8M at default position (last 8M), no LAW needed.
+ *
+ */
+
+struct law_entry law_table[] = {
+	SET_LAW(CONFIG_SYS_FLASH_BASE,     LAW_SIZE_4M,   LAW_TRGT_IF_LBC),
+	SET_LAW(CONFIG_SYS_CPLD_BASE,      LAW_SIZE_4K,   LAW_TRGT_IF_LBC),
+};
+
+int num_law_entries = ARRAY_SIZE(law_table);
diff --git a/board/accton/as5610_52x/tlb.c b/board/accton/as5610_52x/tlb.c
new file mode 100644
index 0000000..0c95c5f
--- /dev/null
+++ b/board/accton/as5610_52x/tlb.c
@@ -0,0 +1,88 @@
+/*
+ * Copyright 2008-2009 Freescale Semiconductor, Inc.
+ *
+ * (C) Copyright 2000
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/mmu.h>
+
+struct fsl_e_tlb_entry tlb_table[] = {
+	/* TLB 0 - for temp stack in cache */
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 4 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 4 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 8 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 8 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+	SET_TLB_ENTRY(0, CONFIG_SYS_INIT_RAM_ADDR + 12 * 1024,
+		      CONFIG_SYS_INIT_RAM_ADDR_PHYS + 12 * 1024,
+		      MAS3_SX|MAS3_SW|MAS3_SR, 0,
+		      0, 0, BOOKE_PAGESZ_4K, 0),
+
+	/* TLB 1 */
+	/* *I*** - Covers boot page */
+	SET_TLB_ENTRY(1, 0xfffff000, 0xfffff000,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 0, BOOKE_PAGESZ_4K, 1),
+
+	/* *I*G* - CCSRBAR */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CCSRBAR, CONFIG_SYS_CCSRBAR_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 1, BOOKE_PAGESZ_1M, 1),
+
+	/* W**G* - Flash, localbus */
+	/* This will be changed to *I*G* after relocation to RAM. */
+	SET_TLB_ENTRY(1, CONFIG_SYS_FLASH_BASE, CONFIG_SYS_FLASH_BASE_PHYS,
+		      MAS3_SX|MAS3_SR, MAS2_W|MAS2_G,
+		      0, 2, CONFIG_SYS_FLASH_TLB_SIZE, 1),
+
+	/* *I*G* - PCIe1 MEM -- first 256M */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_MEM_VIRT, CONFIG_SYS_PCIE1_MEM_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 3, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe1 MEM -- second 256M */
+	SET_TLB_ENTRY(1, (CONFIG_SYS_PCIE1_MEM_VIRT + 0x10000000),
+		      (CONFIG_SYS_PCIE1_MEM_PHYS + 0x10000000),
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 4, BOOKE_PAGESZ_256M, 1),
+
+	/* *I*G* - PCIe1 I/O */
+	SET_TLB_ENTRY(1, CONFIG_SYS_PCIE1_IO_VIRT, CONFIG_SYS_PCIE1_IO_PHYS,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 5, BOOKE_PAGESZ_256K, 1),
+
+	/* *I*G* - CPLD */
+	SET_TLB_ENTRY(1, CONFIG_SYS_CPLD_BASE, CONFIG_SYS_CPLD_BASE,
+		      MAS3_SX|MAS3_SW|MAS3_SR, MAS2_I|MAS2_G,
+		      0, 6, BOOKE_PAGESZ_1K, 1),
+
+};
+
+int num_tlb_entries = ARRAY_SIZE(tlb_table);
diff --git a/board/accton/as5610_52x/usb.c b/board/accton/as5610_52x/usb.c
new file mode 100644
index 0000000..6b5ec66
--- /dev/null
+++ b/board/accton/as5610_52x/usb.c
@@ -0,0 +1,189 @@
+/*
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * USB HUB init via I2C peek/poke.
+ *
+ * SMSC USB2513 hub
+ *
+ * Original code from Accton u-boot source drop:
+ *   bootloader/P2020/drivers/i2c/fsl_i2c.c
+ *   bootloader/P2020/common/cmd_i2c.c
+ *
+ */
+
+#include <common.h>
+#include <command.h>
+#include <environment.h>
+#include <usb.h>
+#include <i2c.h>
+#include <part.h>
+#include "board.h"
+
+#define USB_HUB_I2C_BUS      (0)
+#define USB_HUB_I2C_MUX_ADDR (0x70)
+#define USB_HUB_I2C_MUX_BUS  (4)
+#define USB_HUB_I2C_ADDR     (0x2c)
+
+#define ERROR_RET(x) { if((x) == -1) {printf("%s:%d Fail\n",__func__,__LINE__); return -1;}}
+//#define ERROR_RET(x) x
+
+int usb_hub_init(void)
+{
+	int     i = 0;
+	u8	addr = USB_HUB_I2C_ADDR;
+	u16	word;
+	u8	bdata;
+	u8     *p8;
+
+	puts("USB: ");
+
+	i2c_set_bus_num(USB_HUB_I2C_BUS);
+
+	bdata = 0x1 << USB_HUB_I2C_MUX_BUS;
+	ERROR_RET( i2c_write(USB_HUB_I2C_MUX_ADDR, 0, 1, &bdata, 1) );
+
+	p8 = (u8 *)&word;
+	word = 0x0124;
+	ERROR_RET( i2c_write(addr, 0x00, 1, p8, 2) );
+	word = 0x0104;
+	ERROR_RET( i2c_write(addr, 0x01, 1, p8, 2) );
+	word = 0x0113;
+	ERROR_RET( i2c_write(addr, 0x02, 1, p8, 2));
+	word = 0x0125;
+	ERROR_RET( i2c_write(addr, 0x03, 1, p8, 2));
+	word = 0x01a0;
+	ERROR_RET( i2c_write(addr, 0x04, 1, p8, 2));
+	word = 0x010b;
+	ERROR_RET( i2c_write(addr, 0x05, 1, p8, 2));
+
+	word = 0x019b;
+	ERROR_RET( i2c_write(addr, 0x06, 1, p8, 2));
+	word = 0x0120;
+	ERROR_RET( i2c_write(addr, 0x07, 1, p8, 2));
+	word = 0x0102;
+	ERROR_RET( i2c_write(addr, 0x08, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x09, 1, p8, 2));
+
+	/*graceliu fortuis F change*/
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x0a, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x0b, 1, p8, 2));
+	word = 0x0101;
+	ERROR_RET( i2c_write(addr, 0x0c, 1, p8, 2));
+	word = 0x0132;
+	ERROR_RET( i2c_write(addr, 0x0d, 1, p8, 2));
+	word = 0x0101;
+	ERROR_RET( i2c_write(addr, 0x0e, 1, p8, 2));
+	word = 0x0132;
+	ERROR_RET( i2c_write(addr, 0x0f, 1, p8, 2));
+	word = 0x0132;
+	ERROR_RET( i2c_write(addr, 0x10, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x11, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x12, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x13, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x14, 1, p8, 2));
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0x15, 1, p8, 2));
+	for (i = 0x16; i <= 0xcf; i++) {
+		word = 0x0100;
+		ERROR_RET( i2c_write(addr, i, 1, p8, 2));
+	}
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0xd0, 1, p8, 2));
+	for (i = 0xd1; i <= 0xdf; i++) {
+		word = 0x0100;	/*Kenny Cheng: change from 0x00 to 0x0100*/
+		ERROR_RET( i2c_write(addr, i, 1, p8, 2));
+	}
+	word = 0x0100;
+	ERROR_RET( i2c_write(addr, 0xe0, 1, p8, 2));
+	for (i = 0xe1; i <= 0xf4; i++) {
+		word = 0x0100;	/*Kenny Cheng: change from 0x00 to 0x0100*/
+		ERROR_RET( i2c_write(addr, i, 1, p8, 2));
+	}
+	for (i = 0xf5; i <= 0xfc; i++) {
+		word = 0x0100;
+		ERROR_RET( i2c_write(addr, i, 1, p8, 2));
+	}
+
+	word = 0x0101;
+	ERROR_RET( i2c_write(addr, 0xff, 1, p8, 2));
+
+	puts("USB2513 hub OK\n");
+	return 0;
+}
+
+static int do_usbiddev(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	int devno;
+	int target = -1;
+	block_dev_desc_t *blk_dev;
+	char val[2];
+
+	/*
+	 * The internal USB NAND flash drive is connected to the
+	 * internal hub such that the NAND device always appears as
+	 * the *last* mass storage device.
+	 *
+	 * Sure this is dependent on the depth-first USB topology
+	 * enumeration strategy, but that is not going to change.
+	 */
+	for (devno = 0; ; ++devno) {
+		blk_dev = usb_stor_get_dev(devno);
+		if (blk_dev == NULL)
+			break;
+		if ( (blk_dev->if_type == IF_TYPE_USB) &&
+		     !blk_dev->removable &&
+		     ((blk_dev->type & 0x1F) == DEV_TYPE_HARDDISK) ) {
+			target = devno;
+		}
+	}
+
+	if (target == -1) {
+		printf("Error: Unable to detect internal USB flash device.\n");
+		printf("Perhaps you forgot to run 'usb start' ?\n");
+		return 1;
+	}
+
+	if (target > 9) {
+		printf("Error: Unexpectedly large device number: %d.\n", target);
+		return 1;
+	}
+
+	val[0] = '0' + target;
+	val[1] = 0;
+
+	setenv("usbdev", val);
+
+	return 0;
+}
+
+U_BOOT_CMD(
+	usbiddev,	3,	1,	do_usbiddev,
+	"Identify internal USB NAND flash device number and set\n"
+	"environment variable 'usbdev' to that number.",
+	""
+);
diff --git a/boards.cfg b/boards.cfg
index e4b0d44..fd57186 100644
--- a/boards.cfg
+++ b/boards.cfg
@@ -703,6 +703,7 @@ kmvect1                      powerpc     mpc83xx     km83xx              keymile
 tuge1                        powerpc     mpc83xx     km83xx              keymile        -           tuxx1:KM_DISABLE_APP2,TUGE1
 tuxx1                        powerpc     mpc83xx     km83xx              keymile
 kmsupx5                      powerpc     mpc83xx     km83xx              keymile        -           tuxx1:KM_DISABLE_APP2,KMSUPX5
+AS5610_52X                   powerpc     mpc85xx     as5610_52x          accton         -           AS5610_52X:ONIE_PLATFORM_REV=0
 sbc8548                      powerpc     mpc85xx     sbc8548             -              -           sbc8548
 sbc8548_PCI_33               powerpc     mpc85xx     sbc8548             -              -           sbc8548:PCI,33
 sbc8548_PCI_33_PCIE          powerpc     mpc85xx     sbc8548             -              -           sbc8548:PCI,33,PCIE
diff --git a/common/cmd_sys_eeprom.c b/common/cmd_sys_eeprom.c
index cf2ed1c..3677c1e 100644
--- a/common/cmd_sys_eeprom.c
+++ b/common/cmd_sys_eeprom.c
@@ -1199,18 +1199,35 @@ int mac_read_from_eeprom(void)
 
 	for (i = 0; i < min(maccount, CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS); i++) {
 		if (is_valid_ether_addr(macbase)) {
-			char ethaddr[18];
+            char ethaddr[18], *env;
 			char enetvar[11];
 
 			sprintf(ethaddr, "%02X:%02X:%02X:%02X:%02X:%02X",
 				macbase[0], macbase[1], macbase[2],
 				macbase[3], macbase[4], macbase[5]);
 			sprintf(enetvar, i ? "eth%daddr" : "ethaddr", i);
+
+#if 1
+            /* aaron_lien, 2013/08/05,
+             * Initialize $ethaddr if it is blank or
+             * if the current value is different from non-volatile board information
+             * then change it.
+             */
+            env = getenv(enetvar);
+            if (!env) {
+                setenv(enetvar, ethaddr);
+            } else {
+                if(strcmp(env, ethaddr))
+                    setenv(enetvar, ethaddr);
+            }
+
+#else
 			/* Only initialize environment variables that are blank
 			 * (i.e. have not yet been set)
 			 */
 			if (!getenv(enetvar))
 				setenv(enetvar, ethaddr);
+#endif
 
 			macbase[5]++;
 			if (macbase[5] == 0) {
@@ -1274,3 +1291,36 @@ int populate_serial_number(void)
 }
 
 #endif /* CONFIG_POPULATE_SERIAL_NUMBER */
+
+/* ------------------------------------------------------------------------
+ * FUNCTION NAME: populate_env
+ * PURPOSE:	Read the board information from non-volatile device and
+ *          set the appropriate environment variable.
+ * INPUT:   None
+ * OUTPUT:	None
+ * RETURN:
+ *          0   = Success
+ *          -1  = Fail
+ * NOTES:
+ *  The environment variable is set always.
+ */
+int populate_env(char *env_name,  u8 type_code)
+{
+    char env_str_buf[257];
+    int index;
+    tlvinfo_tlv_t * tlv_item;
+
+    if (read_eeprom(eeprom)) {
+        printf("[Error] Failed to read board information.\n");
+        return -1;
+    }
+
+    if (tlvinfo_find_tlv(eeprom, type_code, &index)) {
+        tlv_item = (tlvinfo_tlv_t *) &eeprom[index];
+        memcpy(env_str_buf, tlv_item->value, tlv_item->length);
+        env_str_buf[tlv_item->length] = 0;
+        setenv(env_name, env_str_buf);
+    }
+
+    return 0;
+}
diff --git a/common/image.c b/common/image.c
index 95498e6..2edd747 100644
--- a/common/image.c
+++ b/common/image.c
@@ -830,6 +830,16 @@ int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
 	*rd_start = 0;
 	*rd_end = 0;
 
+#ifdef CONFIG_FASTPATH
+	if(argc >= 3 && strncmp(argv[2], "-f", 2) ==  0) {
+		/* Look for a "-f" which indicates to skip FASTPATH image block.*/
+		debug ("## Using FASTPATH application image\n");
+
+		/* At next line, we expect this image is a legacy mult-component image. */
+		argc=2;
+     }
+#endif
+
 	/*
 	 * Look for a '-' which indicates to ignore the
 	 * ramdisk argument
@@ -1675,7 +1685,7 @@ int boot_get_fdt(int flag, int argc, char * const argv[],
 			image_check_type(&images->legacy_hdr_os_copy,
 						IH_TYPE_MULTI)) {
 
-		ulong fdt_data, fdt_len;
+		ulong fdt_data, fdt_len, fdt_idx;
 
 		/*
 		 * Now check if we have a legacy multi-component image,
@@ -1685,8 +1695,14 @@ int boot_get_fdt(int flag, int argc, char * const argv[],
 			"component Image at %08lX\n",
 			(ulong)images->legacy_hdr_os);
 
-		image_multi_getimg(images->legacy_hdr_os, 2, &fdt_data,
-					&fdt_len);
+		fdt_idx=2;  /* default fdt index = 2 */
+#ifdef CONFIG_FASTPATH
+		if (argc >= 3 && strncmp(argv[2], "-f", 2) ==  0) {
+			fdt_idx = simple_strtoul(&argv[2][2], NULL, 10);  /* fdt image # */
+			debug("fdt is at image#%ld, argv[2]=%s\n", fdt_idx, argv[2]);
+		}
+#endif
+		image_multi_getimg(images->legacy_hdr_os, fdt_idx, &fdt_data, &fdt_len);
 		if (fdt_len) {
 
 			fdt_blob = (char *)fdt_data;
diff --git a/common/main.c b/common/main.c
index d43c6ae..782a28d 100644
--- a/common/main.c
+++ b/common/main.c
@@ -399,12 +399,6 @@ void main_loop (void)
 	}
 #endif  /* CONFIG_MODEM_SUPPORT */
 
-#ifdef CONFIG_VERSION_VARIABLE
-	{
-		setenv ("ver", version_string);  /* set version variable */
-	}
-#endif /* CONFIG_VERSION_VARIABLE */
-
 #ifdef CONFIG_SYS_HUSH_PARSER
 	u_boot_hush_start ();
 #endif
diff --git a/common/usb_storage.c b/common/usb_storage.c
index fb322b4..3309643 100644
--- a/common/usb_storage.c
+++ b/common/usb_storage.c
@@ -162,7 +162,8 @@ struct us_data {
  * enough free heap space left, but the SCSI READ(10) and WRITE(10) commands are
  * limited to 65535 blocks.
  */
-#define USB_MAX_XFER_BLK	65535
+/*#define USB_MAX_XFER_BLK	65535*/
+#define USB_MAX_XFER_BLK	4095
 #else
 #define USB_MAX_XFER_BLK	20
 #endif
diff --git a/drivers/net/phy/broadcom.c b/drivers/net/phy/broadcom.c
index 16c813f..799aa2c 100644
--- a/drivers/net/phy/broadcom.c
+++ b/drivers/net/phy/broadcom.c
@@ -86,121 +86,6 @@ static int bcm54xx_startup(struct phy_device *phydev)
 	return 0;
 }
 
-/* Broadcom BCM54616S */
-/*
- * "Ethernet@Wirespeed" needs to be enabled to achieve link in certain
- * circumstances.  eg a gigabit TSEC connected to a gigabit switch with
- * a 4-wire ethernet cable.  Both ends advertise gigabit, but can't
- * link.  "Ethernet@Wirespeed" reduces advertised speed until link
- * can be achieved.
- */
-static u32 bcm54616_read_wirespeed(struct phy_device *phydev, u32 reg)
-{
-	return (phy_read(phydev, MDIO_DEVAD_NONE, reg) & 0x8FFF) | 0x8010;
-}
-
-static int bcm54616_config(struct phy_device *phydev)
-{
-	unsigned int reg;
-
-	/* reset the PHY */
-	reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);
-	reg |= BMCR_RESET;
-	phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, reg);
-
-	/* Setup read from auxilary control shadow register 7 */
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54xx_AUXCNTL,
-			MIIM_BCM54xx_AUXCNTL_ENCODE(7));
-	/* Read Misc Control register and or in Ethernet@Wirespeed */
-	reg = bcm54616_read_wirespeed(phydev, MIIM_BCM54xx_AUXCNTL);
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54xx_AUXCNTL, reg);
-
-	/* Enable copper/fiber auto-detect */
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD,
-			MIIM_BCM54XX_SHD_WR_ENCODE(0x1e, 0x027));
-
-	genphy_config_aneg(phydev);
-
-	return 0;
-}
-
-/*
- * Find out if PHY is in copper or serdes mode by looking at Shadow Reg
- * 0x1F - "Mode Control Register"
- */
-static int bcm54616_is_serdes(struct phy_device *phydev)
-{
-	u16 val;
-
-	phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD,
-			MIIM_BCM54XX_SHD_VAL(0x1F));
-	val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD);
-	return (val & 0x0001);
-}
-
-/*
- * Determine SerDes link speed and duplex from Expansion reg 0x42 "Operating
- * Mode Status Register"
- */
-static u32 bcm54616_parse_serdes_sr(struct phy_device *phydev)
-{
-	u16 val;
-	int i = 0;
-
-	/* Wait 1s for link - Clause 37 autonegotiation happens very fast */
-	while (1) {
-		phy_write(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD,
-			MIIM_BCM54XX_SHD_VAL(0x15));
-		val = phy_read(phydev, MDIO_DEVAD_NONE, MIIM_BCM54XX_SHD);
-
-		if (val & 0x0200)
-			break;
-
-		if (i++ > 1000) {
-			phydev->link = 0;
-			return 1;
-		}
-
-		udelay(1000);	/* 1 ms */
-	}
-
-	phydev->link = 1;
-	switch ((val >> 6) & 0x3) {
-	case (0x00):
-		phydev->speed = 10;
-		break;
-	case (0x01):
-		phydev->speed = 100;
-		break;
-	case (0x02):
-		phydev->speed = 1000;
-		break;
-	}
-
-	phydev->duplex = (val & 0x0100) == 0x0100;
-
-	return 0;
-}
-
-/*
- * Figure out if BCM54616 is in serdes or copper mode and determine link
- * configuration accordingly
- */
-static int bcm54616_startup(struct phy_device *phydev)
-{
-	if (bcm54616_is_serdes(phydev)) {
-		bcm54616_parse_serdes_sr(phydev);
-		phydev->port = PORT_FIBRE;
-	} else {
-		/* Wait for auto-negotiation to complete or fail */
-		genphy_update_link(phydev);
-		/* Parse BCM54xx copper aux status register */
-		bcm54xx_parse_status(phydev);
-	}
-
-	return 0;
-}
-
 /* Broadcom BCM5482S */
 /*
  * "Ethernet@Wirespeed" needs to be enabled to achieve link in certain
@@ -394,16 +279,6 @@ static struct phy_driver BCM5481_A2_driver = {
 	.shutdown = &genphy_shutdown,
 };
 
-static struct phy_driver BCM54616S_driver = {
-	.name = "Broadcom BCM54616S",
-	.uid = 0x03625D10,
-	.mask = 0xfffffff0,
-	.features = PHY_GBIT_FEATURES,
-	.config = &bcm54616_config,
-	.startup = &bcm54616_startup,
-	.shutdown = &genphy_shutdown,
-};
-
 int phy_broadcom_init(void)
 {
 	phy_register(&BCM5482S_driver);
@@ -411,7 +286,6 @@ int phy_broadcom_init(void)
 	phy_register(&BCM5461S_driver);
 	phy_register(&BCM54610_A3_driver);
 	phy_register(&BCM5481_A2_driver);
-	phy_register(&BCM54616S_driver);
 
 	return 0;
 }
diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c
index f54b408..c64381d 100644
--- a/drivers/usb/host/ehci-fsl.c
+++ b/drivers/usb/host/ehci-fsl.c
@@ -104,6 +104,10 @@ int ehci_hcd_init(int index, struct ehci_hccr **hccr, struct ehci_hcor **hcor)
 		out_le32(&(*hcor)->or_portsc[0], PORT_PTS_ULPI);
 	}
 
+	/*Fix 2nd usb start hang problem*/
+	//setbits_be32(&ehci->control, USB_EN);
+	udelay(1000);
+
 	out_be32(&ehci->prictrl, 0x0000000c);
 	out_be32(&ehci->age_cnt_limit, 0x00000040);
 	out_be32(&ehci->sictrl, 0x00000001);
diff --git a/include/common.h b/include/common.h
index a29f6a6..4ad17ea 100644
--- a/include/common.h
+++ b/include/common.h
@@ -308,7 +308,6 @@ int	checkdram     (void);
 int	last_stage_init(void);
 extern ulong monitor_flash_len;
 int mac_read_from_eeprom(void);
-int populate_serial_number(void);
 extern u8 _binary_dt_dtb_start[];	/* embedded device tree blob */
 int set_cpu_clk_info(void);
 
diff --git a/include/configs/AS5610_52X.h b/include/configs/AS5610_52X.h
new file mode 100644
index 0000000..bc554be
--- /dev/null
+++ b/include/configs/AS5610_52X.h
@@ -0,0 +1,438 @@
+/*
+ * Curt Brune <curt@cumulusnetworks.com>
+ * Vidya Ravipati <vidya@cumulusnetworks.com>
+ *
+ * Portions Copyright 2007-2009 Freescale Semiconductor, Inc.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/*
+ * Accton AS5610_52X network switch board configuration file
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "configs/common_config.h"
+#include "version.h"
+
+/*#define CONFIG_EQ_DS100KR800*//*Kenny Cheng Remove*/    /* TI Equalizer, DS100KR800 Repeater */
+
+/* High Level Configuration Options */
+#define CONFIG_BOOKE		1	/* BOOKE */
+#define CONFIG_E500		1	/* BOOKE e500 family */
+#define CONFIG_MPC85xx		1	/* MPC8540/60/55/41/48 */
+#define CONFIG_P2020		1	/* P2020 specific */
+#define CONFIG_AS5610_52X	1	/* AS5610_52X board specific */
+#define CONFIG_BOARDNAME		"AS5610_52X"
+#define CONFIG_MP		1	/* support multiple processors */
+
+#define CONFIG_FSL_ELBC		1	/* Has Enhanced localbus controller */
+#define CONFIG_PCI		1	/* enable any pci type devices */
+#define CONFIG_PCIE1		1	/* PCIE controller 1 */
+#undef  CONFIG_PCIE2			/* PCIE controller 2 */
+#undef	CONFIG_PCIE3			/* PCIE controller 3 */
+#define CONFIG_FSL_PCI_INIT	1	/* Use common FSL init code */
+#define CONFIG_FSL_PCIE_RESET	1	/* need PCIe reset errata */
+#define CONFIG_SYS_PCI_64BIT	1	/* enable 64-bit PCI resources */
+
+#define CONFIG_FSL_LAW		1	/* Use common FSL init code */
+
+#define CONFIG_TSEC_ENET		/* tsec ethernet support */
+
+#ifndef __ASSEMBLY__
+extern unsigned long get_clock_freq(void);
+#endif
+
+#if defined(CONFIG_5652_R01A_CLK)
+#  define CONFIG_SYS_CLK_FREQ	66670000
+#  define CONFIG_DDR_CLK_FREQ	66670000
+#elif defined(CONFIG_5652_R01D_CLK)
+#  define CONFIG_SYS_CLK_FREQ	83300000
+#  define CONFIG_DDR_CLK_FREQ	83300000
+#else
+    /* Auto config clock */
+    /*#define CONFIG_AUTO_DETECT_SYSCLK*/
+    #define CONFIG_SYS_CLK_FREQ     get_board_sys_clk()
+    #define CONFIG_DDR_CLK_FREQ     get_board_sys_clk()	/*Define DDR CLK, or it use CCB CLK by default*/
+#endif
+
+/*
+ * These can be toggled for performance analysis, otherwise use default.
+ */
+#define CONFIG_L2_CACHE			/* toggle L2 cache */
+#define CONFIG_BTB			/* toggle branch predition */
+
+/*
+ * Only possible on E500 Version 2 or newer cores.
+ */
+#define CONFIG_ENABLE_36BIT_PHYS	1
+
+#define CONFIG_SYS_MEMTEST_START	0x00000000	/* memtest works on */
+#define CONFIG_SYS_MEMTEST_END		0x7fffffff
+/* do not reset board on panic */
+#define CONFIG_PANIC_HANG		1
+
+/*
+ * Base addresses -- Note these are effective addresses where the
+ * actual resources get mapped (not physical addresses)
+ */
+#define CONFIG_SYS_CCSRBAR		0xff700000	/* relocated CCSRBAR */
+#define CONFIG_SYS_CCSRBAR_PHYS_LOW CONFIG_SYS_CCSRBAR
+
+/* DDR DRAM Setup */
+#define CONFIG_FSL_DDR3			1
+#undef	CONFIG_FSL_DDR_INTERACTIVE
+
+/* ECC will be enabled based on perf_mode environment variable */
+#define	CONFIG_DDR_ECC
+#define CONFIG_ECC_INIT_VIA_DDRCONTROLLER
+#define CONFIG_MEM_INIT_VALUE		0xdeadbeef
+
+#define CONFIG_SYS_DDR_SDRAM_BASE	0x00000000    /* DDR is system memory*/
+#define CONFIG_SYS_SDRAM_BASE		CONFIG_SYS_DDR_SDRAM_BASE
+
+#define CONFIG_NUM_DDR_CONTROLLERS	1
+#define CONFIG_DIMM_SLOTS_PER_CTLR	1
+#define CONFIG_CHIP_SELECTS_PER_CTRL	(1 * CONFIG_DIMM_SLOTS_PER_CTLR)
+
+#define CONFIG_SYS_SDRAM_SIZE		2048		/* DDR is 2GB */
+
+#undef CONFIG_CLOCKS_IN_MHZ
+
+
+/*
+ * Local Bus Definitions
+ */
+
+/*
+ * FLASH on the Local Bus - CS0
+ * One bank, 8M, with 8-bit data width
+ * Boot from BR0/OR0 bank at 0xefc0_0000
+ *
+ * BR0:
+ *    Base address 0 = 0xefc0_0000 = BR0[0:16] = 1110 1111 1100 0000 0
+ *    Port Size = 8 bits = BRx[19:20] = 01
+ *    Use GPCM = BRx[24:26] = 000
+ *    Valid = BRx[31] = 1
+ *
+ * 0	4    8	   12   16   20	   24   28
+ * 1110 1111 1100 0000 0000 1000 0000 0001 = efc00801	 BR0
+ *
+ * OR0:
+ *    Addr Mask = 8M = ORx[0:16] = 1111 1111 1000 0000 0
+ *    Reserved ORx[17:18] = 00
+ *    BCTLD = LBCTL not asserted = ORx[19] = 0
+ *    CSNT = ORx[20] = 1
+ *    ACS = half cycle delay = ORx[21:22] = 11
+ *    XACS = no extra setup = ORx[23] = 1
+ *    SCY = 2 = ORx[24:27] = 1111
+ *    SETA = cycle terminated internaly = ORx[28] = 0
+ *    TRLX = use relaxed timing = ORx[29] = 1
+ *    EHTR = use relaxed timing = ORx[30] = 1
+ *    EAD = use external address latch delay = OR[31] = 1
+ *
+ * 0	4    8	   12   16   20	   24   28
+ * 1111 1000 0000 0000 0000 1111 1111 0111 = ff800FF7    OR0
+ */
+
+#define CONFIG_SYS_FLASH_BASE		0xefc00000	/* start of FLASH 8M */
+#define	CONFIG_SYS_FLASH_BASE_PHYS	CONFIG_SYS_FLASH_BASE
+#define CONFIG_SYS_FLASH_TLB_SIZE	BOOKE_PAGESZ_4M
+
+#define CONFIG_FLASH_BR_PRELIM \
+	(BR_PHYS_ADDR(CONFIG_SYS_FLASH_BASE_PHYS) | BR_PS_8 | BR_V)
+#define CONFIG_FLASH_OR_PRELIM		0xff800ff7	/* slow */
+
+#define CONFIG_SYS_FLASH_BANKS_LIST	{CONFIG_SYS_FLASH_BASE}
+#define CONFIG_SYS_MAX_FLASH_BANKS	1	/* number of banks */
+/* sectors per device  sectors) */
+#define CONFIG_SYS_MAX_FLASH_SECT	64
+#define CONFIG_FLASH_CFI_DRIVER
+#define CONFIG_SYS_FLASH_CFI
+#define CONFIG_SYS_FLASH_EMPTY_INFO
+#define CONFIG_FLASH_SHOW_PROGRESS	45
+#define CONFIG_SYS_FLASH_USE_BUFFER_WRITE
+/* Flash Size is broken due to swizzle feature */
+#define CONFIG_SYS_FLASH_NUM_SECTORS_BROKEN
+#define CONFIG_SYS_FLASH_ERASE_TOUT	30000	/* Flash Erase Timeout (ms) */
+#define CONFIG_SYS_FLASH_WRITE_TOUT	500	/* Flash Write Timeout (ms) */
+/* Flash Full Buffer Write Timeout (ms) */
+#define CONFIG_SYS_FLASH_BUFFER_WRITE_TOUT	500
+#define CONFIG_CMD_LOADS	/* loads */
+
+#ifndef CONFIG_SYS_TEXT_BASE
+#define CONFIG_SYS_TEXT_BASE    0xeff80000
+#endif
+
+#ifndef CONFIG_RESET_VECTOR_ADDRESS
+#define CONFIG_RESET_VECTOR_ADDRESS 0xeffffffc
+#endif
+
+#ifndef CONFIG_SYS_MONITOR_BASE
+#define CONFIG_SYS_MONITOR_BASE CONFIG_SYS_TEXT_BASE    /* start of monitor */
+#endif
+
+#define	CONFIG_BOARD_EARLY_INIT_R	1	/* Call board_pre_init_r */
+#define	CONFIG_BOARD_EARLY_INIT_F	1	/* Call board_pre_init_f */
+#define CONFIG_LAST_STAGE_INIT		1	/* Last minute info/fixups */
+/* FDT fixups before handing to the kernel */
+#define CONFIG_FDT_BOARD_FIXUPS		1
+
+#define CONFIG_SYS_INIT_RAM_LOCK	1
+#define CONFIG_SYS_INIT_RAM_ADDR	0xffd00000	/* Initial L1 address */
+/* Initial L1 address */
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS   CONFIG_SYS_INIT_RAM_ADDR
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_HIGH 0
+#define CONFIG_SYS_INIT_RAM_ADDR_PHYS_LOW CONFIG_SYS_INIT_RAM_ADDR_PHYS
+/* End of used area in RAM */
+#define CONFIG_SYS_INIT_RAM_SIZE	0x00004000
+
+/* num bytes initial data */
+#define CONFIG_SYS_GBL_DATA_SIZE	1024
+#define CONFIG_SYS_GBL_DATA_OFFSET \
+	(CONFIG_SYS_INIT_RAM_SIZE - CONFIG_SYS_GBL_DATA_SIZE)
+#define CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_GBL_DATA_OFFSET
+
+/* Reserve 512 kB for Mon */
+#define CONFIG_SYS_MONITOR_LEN		(512 * 1024)
+/* Reserved for malloc */
+#define CONFIG_SYS_MALLOC_LEN		(256 * 1024)
+
+/* Nor Base Address */
+#define CONFIG_SYS_BR0_PRELIM		CONFIG_FLASH_BR_PRELIM
+/* Nor Options */
+#define CONFIG_SYS_OR0_PRELIM		CONFIG_FLASH_OR_PRELIM
+
+/* Serial Port */
+#define CONFIG_CONS_INDEX		1
+#define CONFIG_SYS_NS16550
+#define CONFIG_SYS_NS16550_SERIAL
+#define CONFIG_SYS_NS16550_REG_SIZE	1
+#define CONFIG_SYS_NS16550_CLK		get_bus_freq(0)
+
+#define CONFIG_SYS_NS16550_COM1	(CONFIG_SYS_CCSRBAR+0x4500)
+#define CONFIG_SYS_NS16550_COM2	(CONFIG_SYS_CCSRBAR+0x4600)
+
+/* I2C  */
+#define CONFIG_FSL_I2C		/* Use FSL common I2C driver */
+#define CONFIG_HARD_I2C		/* I2C with hardware support*/
+#undef	CONFIG_SOFT_I2C		/* I2C bit-banged */
+/* I2C speed and slave address */
+#define CONFIG_SYS_I2C_SPEED		400000
+#define CONFIG_SYS_I2C_OFFSET		0x3000
+#define CONFIG_SYS_I2C2_OFFSET		0x3100
+
+#define CONFIG_I2C_MULTI_BUS
+#define	CONFIG_SYS_MAX_I2C_BUS		2
+#define	CONFIG_I2C_CMD_TREE
+
+/*
+ * CPLD on the Local Bus - CS1
+ *
+ * BR1:
+ *    Base address = 0xEA00_0000 = BRx[0:16] = 1110 1010 0000 0000 0
+ *    Port Size = 8 bits = BRx[19:20] = 01
+ *    Use GPCM = BRx[24:26] = 000
+ *    Valid = BRx[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1110 1010 0000 0000 0000 1000 0000 0001 = EA000801    BR1
+ *
+ * OR1:
+ *    Addr Mask = 32K = ORx[0:16] = 1111 1111 1111 1111 1
+ *    Reserved ORx[17:18] = 00
+ *    BCTLD = LBCTL not asserted = ORx[19] = 0
+ *    CSNT = ORx[20] = 1
+ *    ACS = half cycle delay = ORx[21:22] = 11
+ *    XACS = no extra setup = ORx[23] = 1
+ *    SCY = 6 = ORx[24:27] = 1111
+ *    SETA = cycle terminated internaly = ORx[28] = 0
+ *    TRLX = use relaxed timing = ORx[29] = 1
+ *    EHTR = use relaxed timing = ORx[30] = 1
+ *    EAD = use external address latch delay = OR[31] = 1
+ *
+ * 0    4    8    12   16   20   24   28
+ * 1111 1111 1111 1111 1000 1111 1111 0111 = ffff8ff7    OR1
+ */
+
+#define CONFIG_SYS_CPLD_BASE	0xea000000
+
+#define CONFIG_CPLD_BR_PRELIM \
+	(BR_PHYS_ADDR(CONFIG_SYS_CPLD_BASE) | BR_PS_8 | BR_V)
+/*
+ * use bus timing parms from original boot code
+ */
+#define CONFIG_CPLD_OR_PRELIM	0xffff8ff7 /* slow */
+
+#define CONFIG_SYS_BR1_PRELIM		CONFIG_CPLD_BR_PRELIM
+#define CONFIG_SYS_OR1_PRELIM		CONFIG_CPLD_OR_PRELIM
+
+/*
+ * General PCI
+ * Memory space is mapped 1-1, but I/O space must start from 0.
+ */
+
+/*
+ * Keep these sizes in sync with the LAWs
+ */
+
+#ifdef CONFIG_PCIE1
+#define CONFIG_SYS_PCIE1_MEM_VIRT	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_BUS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_PHYS	0xa0000000
+#define CONFIG_SYS_PCIE1_MEM_SIZE	0x20000000	/* 512M */
+#define CONFIG_SYS_PCIE1_IO_VIRT	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_BUS		0x00000000
+#define CONFIG_SYS_PCIE1_IO_PHYS	0xffc20000
+#define CONFIG_SYS_PCIE1_IO_SIZE	0x00010000	/* 64K */
+#endif
+
+#if defined(CONFIG_PCI) || defined(CONFIG_PCI1)
+#define CONFIG_PCI_PNP			/* do pci plug-and-play */
+#define CONFIG_PCI_SCAN_SHOW		/* show pci devices on startup */
+#endif	/* CONFIG_PCI */
+
+#define CONFIG_RESET_DURATION 20
+#define CONFIG_PCI_BOOTDELAY 1000
+/*
+ * Networking
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+
+#define CONFIG_MII		1	/* MII PHY management */
+/* TODO: Don't allow unregistered phys */
+#undef	CONFIG_MII_DEFAULT_TSEC
+#undef CONFIG_TSEC2
+#undef CONFIG_TSEC3
+#define CONFIG_TSEC1			/* Ethernet  */
+#define	CONFIG_TSEC1_NAME	"eth0"
+
+#define TSEC1_PHY_ADDR		1
+#define TSEC1_PHYIDX		0
+#define TSEC1_FLAGS		(TSEC_GIGABIT | TSEC_REDUCED)
+
+#define CONFIG_ETHPRIME		"eth0"
+
+#define CONFIG_PHY_GIGE		1	/* Include GbE speed/duplex detection */
+#endif	/* CONFIG_TSEC_ENET */
+
+
+
+/*
+ * Environment
+ */
+#define CONFIG_ENV_IS_IN_FLASH	1
+#define CONFIG_ENV_ADDR		0xeff60000
+#define CONFIG_ENV_SECT_SIZE	0x00010000	/* 64K (one sector) */
+#ifdef CONFIG_ENV_SIZE
+#undef CONFIG_ENV_SIZE
+#endif
+#define CONFIG_ENV_SIZE	0x00010000	/* re-define env size */
+
+/*
+ * Board hardware information, stored in flash.
+ */
+#define CONFIG_CMD_SYS_EEPROM
+#define CONFIG_SYS_EEPROM_LOAD_ENV_MAC
+#define CONFIG_SYS_EEPROM_MAX_NUM_ETH_PORTS	1
+
+#define CONFIG_SYS_EEPROM_USE_COMMON_FLASH_IO   /* sys_eeprom read/write function */
+#define CONFIG_SYS_FLASH_HWINFO_ADDR		0xeff70000
+/* 64K(one sector) for HWINFO */
+#define CONFIG_SYS_FLASH_HWINFO_SECT_SIZE	0x00010000
+#define CONFIG_SYS_EEPROM_MAX_SIZE		CONFIG_SYS_FLASH_HWINFO_SECT_SIZE
+
+/*
+ * Enable USB support
+ */
+#define CONFIG_CMD_USB		1	/* USB Support			      */
+#define CONFIG_USB_EHCI         1	/* USB EHCI host controller	      */
+#define CONFIG_USB_EHCI_FSL     1	/* Freescale USB EHCI host controller */
+#define CONFIG_USB_STORAGE      1	/* support for USB storage devices    */
+#define CONFIG_EHCI_HCD_INIT_AFTER_RESET
+
+#undef	CONFIG_WATCHDOG		/* watchdog disabled */
+
+/*
+ * Miscellaneous configurable options
+ */
+#define CONFIG_SYS_LOAD_ADDR	0x2000000	/* default load address */
+#define CONFIG_SYS_PROMPT	"LOADER=> "		/* Monitor Command Prompt */
+/* enable platform specific init */
+#define CONFIG_MISC_INIT_R      1
+#define CONFIG_SYS_LOADS_BAUD_CHANGE	1	/* allow baudrate change */
+
+#if defined(CONFIG_CMD_KGDB)
+/* speed to run kgdb serial port */
+#define CONFIG_KGDB_BAUDRATE	CONFIG_BAUDRATE
+#define CONFIG_KGDB_SER_INDEX	1	/* which serial port to use */
+#endif
+
+/*
+ * Environment Configuration
+ */
+
+#if defined(CONFIG_TSEC_ENET)
+#define CONFIG_HAS_ETH0
+#endif
+
+#define CONFIG_HOSTNAME		as5610_52x-unknown
+#define CONFIG_IPADDR	    192.168.1.10
+#define CONFIG_SERVERIP	    192.168.1.99
+#define CONFIG_GATEWAYIP    192.168.1.10
+#define CONFIG_NETMASK	    255.255.255.0
+
+/*default location for tftp and bootm*/
+#define CONFIG_LOADADDR		CONFIG_SYS_LOAD_ADDR
+
+#define CONFIG_BOOTARGS     "root=/dev/ram rw console=ttyS0,115200 quiet"
+
+#ifdef CONFIG_VERSION_VARIABLE
+        #define VER_VARIABLE "ver=" U_BOOT_VERSION " (" U_BOOT_DATE " - " U_BOOT_TIME ")" CONFIG_IDENT_STRING
+#else
+        #define VER_VARIABLE "\0"
+#endif
+
+/*
+** Platform environment variables needed by the common env
+** infrastructure.
+**
+*/
+#define CONFIG_PLATFORM_ENV	\
+	"consoledev=ttyS0\0"	\
+	"onie_start=0xefc00000\0"	\
+	"onie_sz.b=0x00360000\0"
+
+#define	CONFIG_EXTRA_ENV_SETTINGS	\
+	CONFIG_PLATFORM_ENV		\
+	CONFIG_ONIE_COMMON_UBOOT_ENV	\
+	VER_VARIABLE
+
+/* ICOS Fastpath app image file support */
+#define CONFIG_FASTPATH
+
+#ifdef CONFIG_FASTPATH
+#define CONFIG_FDT_INDEX        4
+#endif
+
+#define CONFIG_CMD_REGINFO      /* register information of TLB and LAW */
+
+#endif	/* __CONFIG_H */
diff --git a/include/environment.h b/include/environment.h
index 82e1c0d..e64b43d 100644
--- a/include/environment.h
+++ b/include/environment.h
@@ -193,10 +193,6 @@ int set_default_vars(int nvars, char * const vars[]);
 /* Import from binary representation into hash table */
 int env_import(const char *buf, int check);
 
-#ifdef CONFIG_ENV_WRITE_DEFAULT_IF_CRC_BAD
-void env_write_default_if_crc_bad(void);
-#endif
-
 #endif /* DO_DEPS_ONLY */
 
 #endif /* _ENVIRONMENT_H_ */
