diff --git a/include/applets.src.h b/include/applets.src.h
index 71b8cbd..62a1c65 100644
--- a/include/applets.src.h
+++ b/include/applets.src.h
@@ -345,6 +345,7 @@ IF_WHOAMI(APPLET_NOFORK(whoami, whoami, BB_DIR_USR_BIN, BB_SUID_DROP, whoami))
 IF_YES(APPLET_NOFORK(yes, yes, BB_DIR_USR_BIN, BB_SUID_DROP, yes))
 IF_ZCIP(APPLET(zcip, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SYS_EEPROM(APPLET_ODDNAME(onie-syseeprom, onie_syseeprom, BB_DIR_USR_BIN, BB_SUID_DROP, onie_syseeprom))
+APPLET_ODDNAME(dni_pdetect, dni_pdetect, BB_DIR_USR_BIN, BB_SUID_DROP, dni_pdetect)
 
 #if !defined(PROTOTYPES) && !defined(NAME_MAIN) && !defined(MAKE_USAGE) \
 	&& !defined(MAKE_LINKS) && !defined(MAKE_SUID)
diff --git a/include/dni_pdetect.h b/include/dni_pdetect.h
new file mode 100644
index 0000000..591667b
--- /dev/null
+++ b/include/dni_pdetect.h
@@ -0,0 +1,40 @@
+int dni_product_name_get(char *r_str);
+int dni_dmidecode_get(char *r_str, int type);
+int dni_eeprom_addr_get(int *r_addr);
+void eeprom_write_protect(int mode);
+
+typedef struct product_s
+{
+    char name[20];
+    int bus;
+    int addr;
+    int reg;
+    int enable_offset;
+    int disenable_offset;
+    int eeprom_addr;
+}product_t;
+
+typedef struct product_name_s
+{
+    char name[20];
+}product_name_t;
+
+typedef struct dni_eeprom_s
+{
+    int addr;
+}dni_eeprom_t;
+
+enum
+{
+    ASSETTAG = 0,
+    PRODUCTNAME,
+    ENABLE_MODE,
+    DISENABLE_MODE,
+};
+
+/*enum
+{
+    ENABLE_MODE = 0,
+    DISENABLE_MODE,
+};*/
+
diff --git a/miscutils/Kbuild.src b/miscutils/Kbuild.src
index 72ddcd1..ded22f3 100644
--- a/miscutils/Kbuild.src
+++ b/miscutils/Kbuild.src
@@ -56,3 +56,4 @@ lib-$(CONFIG_SYS_EEPROM_DEVICE_I2C) += sys_eeprom_i2c.o 24cXX.o
 lib-$(CONFIG_SYS_EEPROM_DEVICE_MTD) += sys_eeprom_mtd.o
 lib-$(CONFIG_SYS_EEPROM_DEVICE_DISK) += sys_eeprom_disk.o
 lib-$(CONFIG_SYS_EEPROM_SYSFS_FILE) += sys_eeprom_sysfs_file.o
+lib-y                     += dni_pdetect.o
diff --git a/miscutils/dni_pdetect.c b/miscutils/dni_pdetect.c
new file mode 100644
index 0000000..342eac1
--- /dev/null
+++ b/miscutils/dni_pdetect.c
@@ -0,0 +1,476 @@
+#include "libbb.h"
+#include <i2c-dev.h>
+#include <getopt.h>
+#include "24cXX.h"
+#include <dni_pdetect.h>
+#include "onie_tlvinfo.h"
+
+#if SYS_EEPROM_I2C_MEM_ADDR_BITS == 8
+    #define EEPROM_TYPE EEPROM_TYPE_8BIT_ADDR
+#elif SYS_EEPROM_I2C_MEM_ADDR_BITS == 16
+    #define EEPROM_TYPE EEPROM_TYPE_16BIT_ADDR
+#else
+    #define EEPROM_TYPE EEPROM_TYPE_UNKNOWN
+#endif
+
+const product_t dni_product_info[] = 
+{
+    {"ag9032v2a", 0, 0x31, 0x14, 0x7c, 0x74, 0x53},
+    {"agc7648sv1", 0, 0x31, 0x14, 0x7c, 0x74, 0x53},
+    {"agc7646slv1b", 0, 0x31, 0x14, 0x09, 0xf4, 0x53},
+    {"agc7648svla", 0, 0x31, 0x14, 0x09, 0xf4, 0x53},
+    {"et-c032if", 0, 0x31, 0x14, 0x08, 0xf4, 0x53},
+};
+
+dni_eeprom_t dni_eeprom = {0};
+
+extern void dni_pdetect_usage(void);
+
+/*
+ *  This macro defines the mbdetect command line command.
+ */
+//usage:#define dni_pdetect_trivial_usage
+//usage:       "[-hgs]"
+//usage:#define dni_pdetect_full_usage "\n\n"
+//usage:     "Display Quanta Switch Motherboard detect result.\n"
+//usage:     "\n       -h      Display usage."
+//usage:     "\n       -g      Output platform product name."
+
+void dni_pdetect_usage(void)
+{
+    static const char *usage =
+       "Display Delta Switch product detect result.\n"
+       "Usage: mbdetect [-h] [-g]\n"
+       "   With no arguments display all product information.\n"
+       "   -h --help\n"
+       "      Display usage\n"
+       "   -g --get-product\n"
+       "      Output platform product name.\n";
+
+    fprintf(stderr, "%s", usage);
+    exit(1);
+}
+
+/*
++ *  do_mbdetect
++ *  This function implements the mbdetect command.
++ */
+int dni_pdetect_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int dni_pdetect_main(int argc, char **argv)
+{
+    int count = 0;
+    int c, option_index;
+    char product_name[50] = {0};
+    char set_cmd[50] = {0};
+    char *subopts;
+    char *value;
+    int index;
+    int i;
+
+    const char *short_options = "hg";
+    const struct option long_options[] = {
+        {"help",        no_argument,          0,    'h'},
+        {"get-project", no_argument,          0,    'g'},
+        {0,                       0,          0,      0},
+    };
+
+    while(TRUE)
+    {
+        c = getopt_long(argc, argv, short_options, long_options, &option_index);
+        if (c == EOF)
+            break;
+
+        count++;
+        switch(c)
+        {
+            case 'h':
+                dni_pdetect_usage();
+                break;
+
+            case 'g':
+                if(dni_product_name_get(product_name) == 0)
+                {
+                    printf("delta_%s\n", product_name);
+                }
+                else
+                {
+                    printf("delta_common\n");
+                }
+                break;
+
+            default:
+                dni_pdetect_usage();
+                break;
+        }
+    }
+}
+
+int dni_dmidecode_get(char *r_str, int type)
+{
+    FILE *fpRead;
+    char cmd[50] = {0};
+    char buf[50] = {0};
+    int rv = 0;
+
+    switch(type)
+    {
+        case ASSETTAG:
+            sprintf(cmd, "dmidecode -s baseboard-asset-tag");
+            break;
+        case PRODUCTNAME:
+            sprintf(cmd, "dmidecode -s system-product-name");
+            break;
+        default:
+            rv = -1;
+            goto END;
+            break;
+    }
+
+    fpRead = popen(cmd, "r");
+    if(fpRead != NULL)
+    {
+        if(fgets(buf, sizeof(buf), fpRead) != NULL)
+        {
+            strcpy(r_str, buf);
+            if(strlen(r_str) > 3)
+            {
+                pclose(fpRead);
+                goto END;
+            }
+            else
+            {
+               rv = -1;
+               goto ERROR;
+            }
+        }
+    }
+    else
+    { 
+        rv = -1;
+    }
+
+ERROR:
+    pclose(fpRead);
+END:
+    return rv;
+}
+
+int dni_syseeprom_productname_get(char *r_str)
+{
+    FILE *fpRead;
+    char cmd[50] = {0};
+    char buf[50] = {0};
+    int rv = 0;
+
+    sprintf(cmd, "onie-syseeprom -g 0x21");
+    fpRead = popen(cmd, "r");
+    if(fpRead != NULL)
+    {
+        if(fgets(buf, sizeof(buf), fpRead) != NULL)
+        {
+            strcpy(r_str, buf);
+            if(strlen(r_str) != 0 & strstr(r_str, "ERROR") == NULL)
+            {
+                pclose(fpRead);
+                goto END;
+            }
+            else
+            {
+                rv = -1;
+                goto ERROR;
+            }
+        }
+    }
+    else
+    {
+        rv = -1;
+    }
+
+ERROR:
+    pclose(fpRead);
+END:
+    return rv;
+}
+
+void eeprom_write_protect(int mode)
+{
+    FILE *pFr  = NULL;
+    FILE *pFw  = NULL;
+    char get_value_cmd[64] = {0};
+    char write_protect_cmd[64] = {0};
+    char r_value[10] = {0};
+    char product_name[50] = {0};
+    char s_type[2] = {0};
+    char s_eeprom_addr[3]= {0};
+    char s_bus[2] = {0};
+    char s_tag[2] = {0};
+    char s_action_num[2] = {0};
+    char s_value[50] = {0};
+    char s_addr[3] = {0};
+    char s_reg[3] = {0};
+    char s_offset[3] = {0};
+    char s_info[8] = {0};
+    int i = 0;
+    int type = 0;
+    int bus = 0;
+    int addr = 0;
+    int reg = 0;
+    int value = 0;
+    int enable_offset = 0;
+    int disenable_offset = 0;
+    int rv = 0;
+    int assettag = 0;
+    int check_num = 0;
+    long action_num = 0;
+    int action_check = 0;
+    char buf[50] = {0};
+
+    if(dni_dmidecode_get(s_value, ASSETTAG) == 0)
+    {
+        /*0    0       53     0   1             31   14  fc    31   14  fd
+          type reserve eeaddr bus action number addr reg value addr reg value
+        */
+        assettag = 1;
+        strncpy(s_type, s_value, 1);
+        type = strtol(s_type, NULL, 10);
+        switch(type)
+        {
+            case 0:
+                strncpy(s_eeprom_addr, s_value + 2, 2);
+                dni_eeprom.addr = strtol(s_eeprom_addr, NULL, 16);            
+                bus = strtol(s_bus, NULL, 10);
+                strncpy(s_action_num, s_value + 5, 1);
+                action_num = strtol(s_action_num, NULL, 10);
+                for(i = 6; i < strlen(s_value); i+=6)
+                {
+                    strncpy(s_info, s_value + i, 6);
+                    strncpy(s_addr, s_info, 2);
+                    strncpy(s_reg, s_info + 2, 2);
+                    strncpy(s_offset, s_info + 4, 2);
+                    addr = strtol(s_addr, NULL, 16);
+                    reg = strtol(s_reg, NULL, 16);
+                    value = strtol(s_offset, NULL, 16);
+                    if(mode == DISENABLE_MODE && action_check < action_num)
+                    {
+                        sprintf(write_protect_cmd, "i2cset -y %d 0x%x 0x%x 0x%x > /dev/null 2>&1", bus, addr, reg, value);
+                        pFw = popen(write_protect_cmd, "r");
+                        if(pFw != NULL)
+                        {
+                            if(fgets(buf, sizeof(buf), pFw) != NULL)
+                            {
+                                pclose(pFw);
+                                goto ASSETTAG_ERROR;
+                            }
+                            pclose(pFw);
+                        }
+                        else
+                        {
+                            pclose(pFw);
+                        }
+                        
+                    }
+                    else if(mode == ENABLE_MODE && action_check >= action_num)
+                    {
+                        sprintf(write_protect_cmd, "i2cset -y %d 0x%x 0x%x 0x%x > /dev/null 2>&1", bus, addr, reg, value);
+                        pFw = popen(write_protect_cmd, "r");
+                        if(pFw != NULL)
+                        {
+                            if(fgets(buf, sizeof(buf), pFw) != NULL)
+                            {
+                                pclose(pFw);
+                                goto ASSETTAG_ERROR;
+                            }
+                            pclose(pFw);
+                        }
+                        else
+                        {
+                            pclose(pFw);
+                        }
+                    }
+                    action_check++;
+                }
+                assettag == 1;
+                break;
+            default:
+ASSETTAG_ERROR:
+                assettag = 0;
+                break;
+        }
+    }
+
+    if(dni_dmidecode_get(product_name, PRODUCTNAME) == 0 && assettag == 0)
+    {
+        for(i = 0; i < sizeof(product_name); i++)
+        {
+            product_name[i] = tolower(product_name[i]);
+        }
+
+        for(i = 0; i < sizeof(dni_product_info)/sizeof(dni_product_info[0]); i++)
+        {
+            if(strstr(product_name, dni_product_info[i].name) != NULL)
+            {
+                bus = dni_product_info[i].bus;
+                addr = dni_product_info[i].addr;
+                reg = dni_product_info[i].reg;
+                enable_offset = dni_product_info[i].enable_offset;
+                disenable_offset = dni_product_info[i].disenable_offset;
+                dni_eeprom.addr = dni_product_info[i].eeprom_addr;
+            }
+            else
+            {
+                check_num++;
+            }
+
+            if(check_num == sizeof(dni_product_info)/sizeof(dni_product_info[0]))
+            {
+                goto ERROR;
+            }
+        } 
+        sprintf(get_value_cmd, "i2cget -y %d 0x%x 0x%x", bus, addr, reg);
+        pFr = popen(get_value_cmd, "r");
+        if( pFr != NULL)
+        {
+            if(fgets(r_value, 10, pFr) != NULL)
+            {
+                rv = strtol(r_value, NULL, 16);
+                switch(mode)
+                {
+                    case ENABLE_MODE:
+                        value = ( rv | enable_offset);
+                        break;
+                    case DISENABLE_MODE:
+                        value = ( rv & disenable_offset);
+                        break;
+                }
+                sprintf(write_protect_cmd, "i2cset -y %d 0x%x 0x%x 0x%x > /dev/null 2>&1", bus, addr, reg, value);
+                pFw = popen(write_protect_cmd, "r");
+                if(pFw != NULL)
+                {
+                    if(fgets(buf, sizeof(buf), pFw) != NULL)
+                    {
+                        pclose(pFw);
+                        pclose(pFr);
+                        goto ERROR;
+                    }
+                    pclose(pFw);
+                }
+                else
+                {
+                    pclose(pFw);
+                }
+            }
+            pclose(pFr);
+        }
+        else
+        {
+            pclose(pFr);
+            goto ERROR;
+        }
+    }
+    else
+    {
+ERROR:
+        printf("ERROR: eeprom write protect failed\n");
+    }
+}
+
+int dni_product_name_get(char *r_str)
+{
+    int rv = 0;
+    int i;
+    char s_value[50] = {0};
+    char product_name[50] = {0};
+    int assettag = 0;
+
+    if(dni_dmidecode_get(s_value, ASSETTAG) == 0)
+    {
+        if(dni_syseeprom_productname_get(product_name) == 0)
+        {
+            for(i = 0; i < sizeof(product_name); i++)
+            {
+                product_name[i] = tolower(product_name[i]);
+            }
+            strcpy(r_str, product_name);
+            goto END;
+        }
+    }
+
+    if(dni_dmidecode_get(product_name, PRODUCTNAME) == 0)
+    {
+        for(i = 0; i < sizeof(product_name); i++)
+        {
+            product_name[i] = tolower(product_name[i]);
+        }
+        strcpy(r_str, product_name);
+        goto END;
+    }
+    else
+    {
+        rv = -1;
+        goto END;
+    }
+END:
+    return rv;
+}
+
+int dni_eeprom_addr_get(int *r_addr)
+{
+    int rv = 1;
+    int i;
+    int check_num = 0;
+    char s_value[50] = {0};
+    char s_eeprom_addr[3]= {0};
+    char product_name[50] = {0};
+    struct eeprom e;
+
+    if(dni_eeprom.addr != 0)
+    {
+        *r_addr = dni_eeprom.addr;
+        goto END;
+    }
+
+    if(dni_dmidecode_get(s_value, ASSETTAG) == 0)
+    {
+        strncpy(s_eeprom_addr, s_value + 2, 2);
+        *r_addr = strtol(s_eeprom_addr, NULL, 16);
+        if(eeprom_open(SYS_EEPROM_I2C_DEVICE, r_addr, EEPROM_TYPE, &e))
+        {
+            goto PRODUCT_GET_EEPROM;
+        }
+        goto END;
+    }
+PRODUCT_GET_EEPROM:
+    if(dni_dmidecode_get(product_name, PRODUCTNAME) == 0)
+    {
+        for(i = 0; i < sizeof(product_name); i++)
+        {
+            product_name[i] = tolower(product_name[i]);
+        }
+
+        for(i = 0; i < sizeof(dni_product_info)/sizeof(dni_product_info[0]); i++)
+        {
+            if(strstr(product_name, dni_product_info[i].name) != NULL)
+            {
+                *r_addr = dni_product_info[i].eeprom_addr;
+                goto END;
+            }
+            else
+            {
+                check_num++;
+            }
+            if(check_num == sizeof(dni_product_info)/sizeof(dni_product_info[0]))
+            {
+                rv = -1;
+                goto END;
+            }
+        }    
+    }
+    else
+    {
+        rv = -1;
+    }
+END:
+    return rv;
+}
+
+
diff --git a/miscutils/sys_eeprom.c b/miscutils/sys_eeprom.c
index a24d6bb..0ac0571 100644
--- a/miscutils/sys_eeprom.c
+++ b/miscutils/sys_eeprom.c
@@ -1,6 +1,7 @@
 #include "libbb.h"
 #include "onie_tlvinfo.h"
 #include <getopt.h>
+#include <dni_pdetect.h>
 
 static u_int8_t eeprom[SYS_EEPROM_SIZE];
 /*
@@ -77,6 +78,7 @@ int onie_syseeprom_main(int argc, char **argv)
 	    snprintf(tokens[(i*2) + 1], 6, "0x%X", tlv_code_list[i].m_code);
     }
     tokens[tlv_code_count*2] = NULL;
+    eeprom_write_protect(DISENABLE_MODE);
 
     while (TRUE) {
 	c = getopt_long(argc, argv, short_options,
@@ -184,5 +186,6 @@ syseeprom_err:
 	free(tokens[i*2]);
 	free(tokens[(i*2) + 1]);
     }
+    eeprom_write_protect(ENABLE_MODE);
     return  (err == 0) ? 0 : 1;
 }
diff --git a/miscutils/sys_eeprom_i2c.c b/miscutils/sys_eeprom_i2c.c
index ed3235b..dae7282 100644
--- a/miscutils/sys_eeprom_i2c.c
+++ b/miscutils/sys_eeprom_i2c.c
@@ -2,6 +2,7 @@
 #include "onie_tlvinfo.h"
 #include "sys_eeprom.h"
 #include "24cXX.h"
+#include <dni_pdetect.h>
 
 #if SYS_EEPROM_I2C_MEM_ADDR_BITS == 8
     #define EEPROM_TYPE EEPROM_TYPE_8BIT_ADDR
@@ -21,10 +22,16 @@ int read_sys_eeprom(void *eeprom_data, int offset, int len)
     int i = 0;
     u_int8_t *c;
     int addr = SYS_EEPROM_OFFSET + offset;
+    int eeprom_addr = 0x0;
 
     c = eeprom_data;
-    if (eeprom_open(SYS_EEPROM_I2C_DEVICE, SYS_EEPROM_I2C_ADDR,
-		    EEPROM_TYPE, &e)) {
+    if(dni_eeprom_addr_get(&eeprom_addr) != 1)
+    {
+        printf("ERROR: Cannot get EEPROM addr, instead use default addr.\n");
+        eeprom_addr = SYS_EEPROM_I2C_ADDR;
+    }
+    if (eeprom_open(SYS_EEPROM_I2C_DEVICE, eeprom_addr,
+                    EEPROM_TYPE, &e)) {
 	printf("ERROR: Cannot open I2C device\n");
 	return -1;
     }
@@ -46,10 +53,17 @@ int write_sys_eeprom(void *eeprom_data, int len)
     int i = 0;
     u_int8_t *c;
     u_int16_t  addr = SYS_EEPROM_OFFSET;
+    int eeprom_addr = 0x0;
 
     c = eeprom_data;
+    if(dni_eeprom_addr_get(&eeprom_addr) != 1)
+    {
+        printf("ERROR: Cannot get EEPROM addr, instead use default addr.\n");
+        eeprom_addr = SYS_EEPROM_I2C_ADDR;
+    }
+
     for (i = 0; i < len; i++) {
-	if (eeprom_open(SYS_EEPROM_I2C_DEVICE, SYS_EEPROM_I2C_ADDR,
+	if (eeprom_open(SYS_EEPROM_I2C_DEVICE, eeprom_addr,
 			EEPROM_TYPE, &e)) {
 	    printf("ERROR: Cannot open I2C device\n");
 	    return -1;
